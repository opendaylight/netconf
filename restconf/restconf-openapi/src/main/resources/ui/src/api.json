{
  "openapi": "3.0.3",
  "info": {
    "version": "1.0.0",
    "title": "Controller modules of RESTCONF",
    "description": "We are providing full API for configurational data which can be edited (by POST, PUT, PATCH and DELETE).\nFor operational data we only provide GET API.\n\nFor majority of request you can see only config data in examples. That's because we can show only one example\nper request. The exception when you can see operational data in example is when data are representing\noperational (config false) container with no config data in it."
  },
  "servers": [
    {
      "url": "http://localhost:8181/"
    }
  ],
  "paths": {
    "/rests/data/aaa:authentication": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - authentication",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "domains": {
                    "$ref": "#/components/schemas/aaa_authentication_domains",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - authentication",
        "requestBody": {
          "description": "authentication",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:authentication": {
                    "$ref": "#/components/schemas/aaa_authentication",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - authentication",
        "requestBody": {
          "description": "authentication",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:authentication": {
                    "$ref": "#/components/schemas/aaa_authentication",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - authentication",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - authentication",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "authentication": {
                      "$ref": "#/components/schemas/aaa_authentication",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/domains": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - domains",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "domains": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_domains_domains",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains_domains"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - domains",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:domains": {
                    "$ref": "#/components/schemas/aaa_authentication_domains",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - domains",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:domains": {
                    "$ref": "#/components/schemas/aaa_authentication_domains",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - domains",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - domains",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_domains"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "domains": {
                      "$ref": "#/components/schemas/aaa_authentication_domains",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/domains/domains={domainid}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - domains",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:domains": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_domains_domains",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains_domains"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "domainid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - domains",
        "requestBody": {
          "description": "domains",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:domains": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_domains_domains",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_domains_domains"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "domainid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - domains",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "domainid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - domains",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_domains_domains"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "domains": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_authentication_domains_domains",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "domainid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/users": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - users",
        "requestBody": {
          "description": "users",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "users": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_users_users",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_users_users"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - users",
        "requestBody": {
          "description": "users",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:users": {
                    "$ref": "#/components/schemas/aaa_authentication_users",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_users"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - users",
        "requestBody": {
          "description": "users",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:users": {
                    "$ref": "#/components/schemas/aaa_authentication_users",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_users"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - users",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - users",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_users"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "users": {
                      "$ref": "#/components/schemas/aaa_authentication_users",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/users/users={userid}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - users",
        "requestBody": {
          "description": "users",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:users": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_users_users",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_users_users"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "userid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name@domain'."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - users",
        "requestBody": {
          "description": "users",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:users": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_users_users",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_users_users"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "userid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name@domain'."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - users",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "userid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name@domain'."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - users",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_users_users"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "users": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_authentication_users_users",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "userid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name@domain'."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/roles": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - roles",
        "requestBody": {
          "description": "roles",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "roles": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_roles_roles",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_roles_roles"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - roles",
        "requestBody": {
          "description": "roles",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:roles": {
                    "$ref": "#/components/schemas/aaa_authentication_roles",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_roles"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - roles",
        "requestBody": {
          "description": "roles",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:roles": {
                    "$ref": "#/components/schemas/aaa_authentication_roles",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_roles"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - roles",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - roles",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_roles"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "roles": {
                      "$ref": "#/components/schemas/aaa_authentication_roles",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/roles/roles={roleid}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - roles",
        "requestBody": {
          "description": "roles",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:roles": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_roles_roles",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_roles_roles"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "roleid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - roles",
        "requestBody": {
          "description": "roles",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:roles": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_roles_roles",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_roles_roles"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "roleid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - roles",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "roleid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - roles",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_roles_roles"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "roles": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_authentication_roles_roles",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "roleid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'name'."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/grants": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - grants",
        "requestBody": {
          "description": "grants",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "grants": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_grants_grants",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_grants_grants"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - grants",
        "requestBody": {
          "description": "grants",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:grants": {
                    "$ref": "#/components/schemas/aaa_authentication_grants",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_grants"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - grants",
        "requestBody": {
          "description": "grants",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:grants": {
                    "$ref": "#/components/schemas/aaa_authentication_grants",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_grants"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - grants",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - grants",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_grants"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "grants": {
                      "$ref": "#/components/schemas/aaa_authentication_grants",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:authentication/grants/grants={grantid}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - grants",
        "requestBody": {
          "description": "grants",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:grants": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_grants_grants",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_grants_grants"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "grantid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'userid@roleid@domainid'."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - grants",
        "requestBody": {
          "description": "grants",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:grants": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_authentication_grants_grants",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_authentication_grants_grants"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "grantid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'userid@roleid@domainid'."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - grants",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "grantid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'userid@roleid@domainid'."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - grants",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_authentication_grants_grants"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "grants": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_authentication_grants_grants",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "grantid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An internal wiring detail in the form 'userid@roleid@domainid'."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:http-authorization": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - http-authorization",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "policies": {
                    "$ref": "#/components/schemas/aaa_http-authorization_policies",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - http-authorization",
        "requestBody": {
          "description": "http-authorization",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:http-authorization": {
                    "$ref": "#/components/schemas/aaa_http-authorization",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - http-authorization",
        "requestBody": {
          "description": "http-authorization",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:http-authorization": {
                    "$ref": "#/components/schemas/aaa_http-authorization",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - http-authorization",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - http-authorization",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_http-authorization"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "http-authorization": {
                      "$ref": "#/components/schemas/aaa_http-authorization",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:http-authorization/policies": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa - policies",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "policies": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies_policies",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies_policies"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - policies",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:policies": {
                    "$ref": "#/components/schemas/aaa_http-authorization_policies",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - policies",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:policies": {
                    "$ref": "#/components/schemas/aaa_http-authorization_policies",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - policies",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - policies",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_http-authorization_policies"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "policies": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:http-authorization/policies/policies={resource}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - policies",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:policies": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies_policies",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies_policies"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - policies",
        "requestBody": {
          "description": "policies",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:policies": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies_policies",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies_policies"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - policies",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - policies",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_http-authorization_policies_policies"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "policies": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_http-authorization_policies_policies",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa:http-authorization/policies/policies={resource}/permissions": {
      "put": {
        "description": "",
        "summary": "PUT - aaa - Controller - permissions",
        "requestBody": {
          "description": "permissions",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa:permissions": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa - Controller - permissions",
        "requestBody": {
          "description": "permissions",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa:permissions": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa - permissions",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa - permissions",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "permissions": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa"
        ],
        "parameters": [
          {
            "name": "resource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-app-config:shiro-configuration": {
      "post": {
        "description": "AAA shiro related configuration.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa-app-config - shiro-configuration",
        "requestBody": {
          "description": "main",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "main": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "put": {
        "description": "AAA shiro related configuration.",
        "summary": "PUT - aaa-app-config - Controller - shiro-configuration",
        "requestBody": {
          "description": "shiro-configuration",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-app-config:shiro-configuration": {
                    "$ref": "#/components/schemas/aaa-app-config_shiro-configuration",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "patch": {
        "description": "AAA shiro related configuration.",
        "summary": "PATCH - aaa-app-config - Controller - shiro-configuration",
        "requestBody": {
          "description": "shiro-configuration",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-app-config:shiro-configuration": {
                    "$ref": "#/components/schemas/aaa-app-config_shiro-configuration",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "delete": {
        "description": "AAA shiro related configuration.",
        "summary": "DELETE - Controller - aaa-app-config - shiro-configuration",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "get": {
        "description": "AAA shiro related configuration.",
        "summary": "GET - Controller - aaa-app-config - shiro-configuration",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-app-config_shiro-configuration"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "shiro-configuration": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-app-config:shiro-configuration/main={pair-key}": {
      "put": {
        "description": "The main section of shiro.ini.",
        "summary": "PUT - aaa-app-config - Controller - main",
        "requestBody": {
          "description": "main",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-app-config:main": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "patch": {
        "description": "The main section of shiro.ini.",
        "summary": "PATCH - aaa-app-config - Controller - main",
        "requestBody": {
          "description": "main",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-app-config:main": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "delete": {
        "description": "The main section of shiro.ini.",
        "summary": "DELETE - Controller - aaa-app-config - main",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "get": {
        "description": "The main section of shiro.ini.",
        "summary": "GET - Controller - aaa-app-config - main",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "main": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-app-config:shiro-configuration/urls={pair-key}": {
      "put": {
        "description": "The urls section of shiro.ini.",
        "summary": "PUT - aaa-app-config - Controller - urls",
        "requestBody": {
          "description": "urls",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-app-config:urls": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "patch": {
        "description": "The urls section of shiro.ini.",
        "summary": "PATCH - aaa-app-config - Controller - urls",
        "requestBody": {
          "description": "urls",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-app-config:urls": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "delete": {
        "description": "The urls section of shiro.ini.",
        "summary": "DELETE - Controller - aaa-app-config - urls",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          }
        ]
      },
      "get": {
        "description": "The urls section of shiro.ini.",
        "summary": "GET - Controller - aaa-app-config - urls",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "urls": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "pair-key",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The key."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-app-config:datastore-config": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-app-config - Controller - datastore-config",
        "requestBody": {
          "description": "datastore-config",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-app-config:datastore-config": {
                    "$ref": "#/components/schemas/aaa-app-config_datastore-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_datastore-config"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-app-config - Controller - datastore-config",
        "requestBody": {
          "description": "datastore-config",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-app-config:datastore-config": {
                    "$ref": "#/components/schemas/aaa-app-config_datastore-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-app-config_datastore-config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-app-config - datastore-config",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-app-config - datastore-config",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-app-config_datastore-config"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "datastore-config": {
                      "$ref": "#/components/schemas/aaa-app-config_datastore-config",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-app-config"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert:aaa-cert-service-config": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa-cert - aaa-cert-service-config",
        "requestBody": {
          "description": "ctlKeystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ctlKeystore": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert - Controller - aaa-cert-service-config",
        "requestBody": {
          "description": "aaa-cert-service-config",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert:aaa-cert-service-config": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert - Controller - aaa-cert-service-config",
        "requestBody": {
          "description": "aaa-cert-service-config",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert:aaa-cert-service-config": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert - aaa-cert-service-config",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert - aaa-cert-service-config",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "aaa-cert-service-config": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert:aaa-cert-service-config/ctlKeystore": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa-cert - ctlKeystore",
        "requestBody": {
          "description": "cipher-suites",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "cipher-suites": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert - Controller - ctlKeystore",
        "requestBody": {
          "description": "ctlKeystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert:ctlKeystore": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert - Controller - ctlKeystore",
        "requestBody": {
          "description": "ctlKeystore",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert:ctlKeystore": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert - ctlKeystore",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert - ctlKeystore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "ctlKeystore": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert:aaa-cert-service-config/ctlKeystore/cipher-suites": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert - Controller - cipher-suites",
        "requestBody": {
          "description": "cipher-suites",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert:cipher-suites": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert - Controller - cipher-suites",
        "requestBody": {
          "description": "cipher-suites",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert:cipher-suites": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert - cipher-suites",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert - cipher-suites",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "cipher-suites": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert:aaa-cert-service-config/trustKeystore": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert - Controller - trustKeystore",
        "requestBody": {
          "description": "trustKeystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert:trustKeystore": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert - Controller - trustKeystore",
        "requestBody": {
          "description": "trustKeystore",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert:trustKeystore": {
                    "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert - trustKeystore",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert - trustKeystore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "trustKeystore": {
                      "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert-mdsal:key-stores": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - aaa-cert-mdsal - key-stores",
        "requestBody": {
          "description": "ssl-data",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ssl-data": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert-mdsal - Controller - key-stores",
        "requestBody": {
          "description": "key-stores",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:key-stores": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert-mdsal - Controller - key-stores",
        "requestBody": {
          "description": "key-stores",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:key-stores": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert-mdsal - key-stores",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert-mdsal - key-stores",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "key-stores": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert-mdsal:key-stores/ssl-data={bundle-name}": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert-mdsal - Controller - ssl-data",
        "requestBody": {
          "description": "ssl-data",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:ssl-data": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert-mdsal - Controller - ssl-data",
        "requestBody": {
          "description": "ssl-data",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:ssl-data": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert-mdsal - ssl-data",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert-mdsal - ssl-data",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "ssl-data": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert-mdsal:key-stores/ssl-data={bundle-name}/odl-keystore": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert-mdsal - Controller - odl-keystore",
        "requestBody": {
          "description": "odl-keystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:odl-keystore": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert-mdsal - Controller - odl-keystore",
        "requestBody": {
          "description": "odl-keystore",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:odl-keystore": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert-mdsal - odl-keystore",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert-mdsal - odl-keystore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "odl-keystore": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert-mdsal:key-stores/ssl-data={bundle-name}/trust-keystore": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert-mdsal - Controller - trust-keystore",
        "requestBody": {
          "description": "trust-keystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:trust-keystore": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert-mdsal - Controller - trust-keystore",
        "requestBody": {
          "description": "trust-keystore",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:trust-keystore": {
                    "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert-mdsal - trust-keystore",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert-mdsal - trust-keystore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "trust-keystore": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-cert-mdsal:key-stores/ssl-data={bundle-name}/cipher-suites": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-cert-mdsal - Controller - cipher-suites",
        "requestBody": {
          "description": "cipher-suites",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:cipher-suites": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-cert-mdsal - Controller - cipher-suites",
        "requestBody": {
          "description": "cipher-suites",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-cert-mdsal:cipher-suites": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-cert-mdsal - cipher-suites",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-cert-mdsal - cipher-suites",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "cipher-suites": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-mdsal"
        ],
        "parameters": [
          {
            "name": "bundle-name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "bundle name"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/aaa-cert-rpc:getODLCertificate": {
      "post": {
        "description": "Get the ODL keystore certificate",
        "summary": "POST - Controller - aaa-cert-rpc - getODLCertificate",
        "requestBody": {
          "description": "getODLCertificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC getODLCertificate success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getODLCertificate_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getODLCertificate_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-rpc"
        ],
        "parameters": []
      }
    },
    "/rests/operations/aaa-cert-rpc:getODLCertificateReq": {
      "post": {
        "description": "Generate a certificate request from the ODL keystore to be signed by a CA",
        "summary": "POST - Controller - aaa-cert-rpc - getODLCertificateReq",
        "requestBody": {
          "description": "getODLCertificateReq_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC getODLCertificateReq success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getODLCertificateReq_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getODLCertificateReq_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-rpc"
        ],
        "parameters": []
      }
    },
    "/rests/operations/aaa-cert-rpc:setODLCertificate": {
      "post": {
        "description": "The certificate should be generated based on\na certificate request generated from the ctl.jks\nkeystore otherwise the certificate will not be added to ctl keystore",
        "summary": "POST - Controller - aaa-cert-rpc - setODLCertificate",
        "requestBody": {
          "description": "setODLCertificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/aaa-cert-rpc_setODLCertificate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-rpc_setODLCertificate_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC setODLCertificate success"
          }
        },
        "tags": [
          "Controller aaa-cert-rpc"
        ],
        "parameters": []
      }
    },
    "/rests/operations/aaa-cert-rpc:setNodeCertificate": {
      "post": {
        "description": "Set the certificate of the network node that will communicate with opendaylight through TLS connection",
        "summary": "POST - Controller - aaa-cert-rpc - setNodeCertificate",
        "requestBody": {
          "description": "setNodeCertificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/aaa-cert-rpc_setNodeCertificate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-rpc_setNodeCertificate_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC setNodeCertificate success"
          }
        },
        "tags": [
          "Controller aaa-cert-rpc"
        ],
        "parameters": []
      }
    },
    "/rests/operations/aaa-cert-rpc:getNodeCertificate": {
      "post": {
        "description": "Get the network node certificate based on node alias",
        "summary": "POST - Controller - aaa-cert-rpc - getNodeCertificate",
        "requestBody": {
          "description": "getNodeCertificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/aaa-cert-rpc_getNodeCertificate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-cert-rpc_getNodeCertificate_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC getNodeCertificate success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getNodeCertificate_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-cert-rpc_getNodeCertificate_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-cert-rpc"
        ],
        "parameters": []
      }
    },
    "/rests/data/aaa-encrypt-service-config:aaa-encrypt-service-config": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-encrypt-service-config - Controller - aaa-encrypt-service-config",
        "requestBody": {
          "description": "aaa-encrypt-service-config",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-encrypt-service-config:aaa-encrypt-service-config": {
                    "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-encrypt-service-config"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-encrypt-service-config - Controller - aaa-encrypt-service-config",
        "requestBody": {
          "description": "aaa-encrypt-service-config",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-encrypt-service-config:aaa-encrypt-service-config": {
                    "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-encrypt-service-config"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-encrypt-service-config - aaa-encrypt-service-config",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-encrypt-service-config"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-encrypt-service-config - aaa-encrypt-service-config",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "aaa-encrypt-service-config": {
                      "$ref": "#/components/schemas/aaa-encrypt-service-config_aaa-encrypt-service-config",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-encrypt-service-config"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/aaa-password-service-config:password-service-config": {
      "put": {
        "description": "",
        "summary": "PUT - aaa-password-service-config - Controller - password-service-config",
        "requestBody": {
          "description": "password-service-config",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "aaa-password-service-config:password-service-config": {
                    "$ref": "#/components/schemas/aaa-password-service-config_password-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-password-service-config_password-service-config"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-password-service-config"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - aaa-password-service-config - Controller - password-service-config",
        "requestBody": {
          "description": "password-service-config",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "aaa-password-service-config:password-service-config": {
                    "$ref": "#/components/schemas/aaa-password-service-config_password-service-config",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/aaa-password-service-config_password-service-config"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller aaa-password-service-config"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - aaa-password-service-config - password-service-config",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller aaa-password-service-config"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - aaa-password-service-config - password-service-config",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/aaa-password-service-config_password-service-config"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "password-service-config": {
                      "$ref": "#/components/schemas/aaa-password-service-config_password-service-config",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller aaa-password-service-config"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/cluster-admin:add-shard-replica": {
      "post": {
        "description": "Adds a replica of a shard to this node and joins it to an existing cluster. The shard must\nalready have a module configuration defined for it and there must already be a shard existing on\nanother node with a leader. This RPC first contacts peer member seed nodes searching for a shard.\nWhen found, an AddServer message is sent to the shard leader and applied as described in the Raft\npaper.",
        "summary": "POST - Controller - cluster-admin - add-shard-replica",
        "requestBody": {
          "description": "add-shard-replica_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_add-shard-replica_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_add-shard-replica_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC add-shard-replica success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:remove-shard-replica": {
      "post": {
        "description": "Removes an existing replica of a shard from this node via the RemoveServer mechanism as\ndescribed in the Raft paper.",
        "summary": "POST - Controller - cluster-admin - remove-shard-replica",
        "requestBody": {
          "description": "remove-shard-replica_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_remove-shard-replica_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_remove-shard-replica_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC remove-shard-replica success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:make-leader-local": {
      "post": {
        "description": "Attempts to move the shard leader of the given module based shard to the local node.\nThe rpc returns a response after handling of the underlying MakeLeaderLocal message completes.\nThis operation fails if there is no current shard leader due to lack of network connectivity or\na cluster majority. In addition, if the local node is not up to date with the current leader,\nan attempt is made to first sync the local node with the leader. If this cannot be achieved\nwithin two election timeout periods the operation fails.",
        "summary": "POST - Controller - cluster-admin - make-leader-local",
        "requestBody": {
          "description": "make-leader-local_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_make-leader-local_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_make-leader-local_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC make-leader-local success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:add-replicas-for-all-shards": {
      "post": {
        "description": "Adds replicas on this node for all currently defined shards. This is equivalent to issuing\nan add-shard-replica RPC for all shards.",
        "summary": "POST - Controller - cluster-admin - add-replicas-for-all-shards",
        "requestBody": {
          "description": "add-replicas-for-all-shards_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC add-replicas-for-all-shards success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_add-replicas-for-all-shards_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_add-replicas-for-all-shards_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:remove-all-shard-replicas": {
      "post": {
        "description": "Removes replicas for all shards on this node. This is equivalent to issuing\na remove-shard-replica for all shards and essentially removes this node from a cluster.",
        "summary": "POST - Controller - cluster-admin - remove-all-shard-replicas",
        "requestBody": {
          "description": "remove-all-shard-replicas_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_remove-all-shard-replicas_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_remove-all-shard-replicas_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC remove-all-shard-replicas success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_remove-all-shard-replicas_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_remove-all-shard-replicas_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:change-member-voting-states-for-shard": {
      "post": {
        "description": "Changes the voting states, either voting or non-voting, of cluster members for a shard.\nNon-voting members will no longer participate in leader elections and consensus but will be\nreplicated. This is useful for having a set of members serve as a backup cluster in case the\nprimary voting cluster suffers catastrophic failure. This RPC can be issued to any cluster member\nand will be forwarded to the leader.",
        "summary": "POST - Controller - cluster-admin - change-member-voting-states-for-shard",
        "requestBody": {
          "description": "change-member-voting-states-for-shard_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-shard_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-shard_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC change-member-voting-states-for-shard success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:change-member-voting-states-for-all-shards": {
      "post": {
        "description": "Changes the voting states, either voting or non-voting, of cluster members for all shards.\nNon-voting members will no longer participate in leader elections and consensus but will be\nreplicated. This is useful for having a set of members serve as a backup cluster in case the\nprimary voting cluster suffers catastrophic failure. This RPC can be issued to any cluster member\nand will be forwarded to the leader.",
        "summary": "POST - Controller - cluster-admin - change-member-voting-states-for-all-shards",
        "requestBody": {
          "description": "change-member-voting-states-for-all-shards_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-all-shards_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-all-shards_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC change-member-voting-states-for-all-shards success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-all-shards_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_change-member-voting-states-for-all-shards_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:flip-member-voting-states-for-all-shards": {
      "post": {
        "description": "Flips the voting states of all cluster members for all shards, such that if a member\nwas voting it becomes non-voting and vice versa.",
        "summary": "POST - Controller - cluster-admin - flip-member-voting-states-for-all-shards",
        "requestBody": {
          "description": "flip-member-voting-states-for-all-shards_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC flip-member-voting-states-for-all-shards success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_flip-member-voting-states-for-all-shards_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_flip-member-voting-states-for-all-shards_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:backup-datastore": {
      "post": {
        "description": "Creates a backup file of the datastore state",
        "summary": "POST - Controller - cluster-admin - backup-datastore",
        "requestBody": {
          "description": "backup-datastore_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_backup-datastore_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_backup-datastore_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC backup-datastore success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:get-shard-role": {
      "post": {
        "description": "Returns the current role for the requested module shard.",
        "summary": "POST - Controller - cluster-admin - get-shard-role",
        "requestBody": {
          "description": "get-shard-role_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_get-shard-role_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_get-shard-role_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-shard-role success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_get-shard-role_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_get-shard-role_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:locate-shard": {
      "post": {
        "description": "Return the transport-level information about where a shard has a home.",
        "summary": "POST - Controller - cluster-admin - locate-shard",
        "requestBody": {
          "description": "locate-shard_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/cluster-admin_locate-shard_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/cluster-admin_locate-shard_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC locate-shard success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_locate-shard_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_locate-shard_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:get-known-clients-for-all-shards": {
      "post": {
        "description": "Request all shards to report their known frontend clients. This is useful for determining what\ngeneration should a resurrected member node should use.",
        "summary": "POST - Controller - cluster-admin - get-known-clients-for-all-shards",
        "requestBody": {
          "description": "get-known-clients-for-all-shards_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-known-clients-for-all-shards success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_get-known-clients-for-all-shards_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/cluster-admin_get-known-clients-for-all-shards_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:activate-eos-datacenter": {
      "post": {
        "description": "Activates the datacenter that the node this rpc is called on belongs to. The caller must maintain\nonly a single active datacenter at a time as the singleton components will interfere with each\nother otherwise. This only needs to be used if configuring multiple datacenters or if not using\ndefault datacenter.",
        "summary": "POST - Controller - cluster-admin - activate-eos-datacenter",
        "requestBody": {
          "description": "activate-eos-datacenter_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC activate-eos-datacenter success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/operations/cluster-admin:deactivate-eos-datacenter": {
      "post": {
        "description": "Deactivates the datacenter that the node this rpc is called on belongs to. The caller must maintain\nonly a single active datacenter at a time as the singleton components will interfere with each\nother otherwise. This only needs to be used if configuring multiple datacenters or if not using\ndefault datacenter.",
        "summary": "POST - Controller - cluster-admin - deactivate-eos-datacenter",
        "requestBody": {
          "description": "deactivate-eos-datacenter_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC deactivate-eos-datacenter success"
          }
        },
        "tags": [
          "Controller cluster-admin"
        ],
        "parameters": []
      }
    },
    "/rests/data/distributed-datastore-provider:data-store-properties-container": {
      "put": {
        "description": "",
        "summary": "PUT - distributed-datastore-provider - Controller - data-store-properties-container",
        "requestBody": {
          "description": "data-store-properties-container",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "distributed-datastore-provider:data-store-properties-container": {
                    "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller distributed-datastore-provider"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - distributed-datastore-provider - Controller - data-store-properties-container",
        "requestBody": {
          "description": "data-store-properties-container",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "distributed-datastore-provider:data-store-properties-container": {
                    "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller distributed-datastore-provider"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - distributed-datastore-provider - data-store-properties-container",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller distributed-datastore-provider"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - distributed-datastore-provider - data-store-properties-container",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "data-store-properties-container": {
                      "$ref": "#/components/schemas/distributed-datastore-provider_data-store-properties-container",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller distributed-datastore-provider"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/ietf-netconf:get-config": {
      "post": {
        "description": "Retrieve all or part of a specified configuration.",
        "summary": "POST - Controller - ietf-netconf - get-config",
        "requestBody": {
          "description": "get-config_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_get-config_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_get-config_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-config success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf_get-config_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf_get-config_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:edit-config": {
      "post": {
        "description": "The <edit-config> operation loads all or part of a specified\nconfiguration to the specified target configuration.",
        "summary": "POST - Controller - ietf-netconf - edit-config",
        "requestBody": {
          "description": "edit-config_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_edit-config_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_edit-config_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC edit-config success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:copy-config": {
      "post": {
        "description": "Create or replace an entire configuration datastore with the\ncontents of another complete configuration datastore.",
        "summary": "POST - Controller - ietf-netconf - copy-config",
        "requestBody": {
          "description": "copy-config_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_copy-config_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_copy-config_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC copy-config success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:delete-config": {
      "post": {
        "description": "Delete a configuration datastore.",
        "summary": "POST - Controller - ietf-netconf - delete-config",
        "requestBody": {
          "description": "delete-config_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_delete-config_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_delete-config_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC delete-config success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:lock": {
      "post": {
        "description": "The lock operation allows the client to lock the configuration\nsystem of a device.",
        "summary": "POST - Controller - ietf-netconf - lock",
        "requestBody": {
          "description": "lock_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_lock_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_lock_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC lock success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:unlock": {
      "post": {
        "description": "The unlock operation is used to release a configuration lock,\npreviously obtained with the 'lock' operation.",
        "summary": "POST - Controller - ietf-netconf - unlock",
        "requestBody": {
          "description": "unlock_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_unlock_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_unlock_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC unlock success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:get": {
      "post": {
        "description": "Retrieve running configuration and device state information.",
        "summary": "POST - Controller - ietf-netconf - get",
        "requestBody": {
          "description": "get_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_get_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_get_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf_get_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf_get_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:close-session": {
      "post": {
        "description": "Request graceful termination of a NETCONF session.",
        "summary": "POST - Controller - ietf-netconf - close-session",
        "requestBody": {
          "description": "close-session_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC close-session success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:kill-session": {
      "post": {
        "description": "Force the termination of a NETCONF session.",
        "summary": "POST - Controller - ietf-netconf - kill-session",
        "requestBody": {
          "description": "kill-session_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_kill-session_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_kill-session_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC kill-session success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:commit": {
      "post": {
        "description": "Commit the candidate configuration as the device's new\ncurrent configuration.",
        "summary": "POST - Controller - ietf-netconf - commit",
        "requestBody": {
          "description": "commit_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_commit_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_commit_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC commit success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:discard-changes": {
      "post": {
        "description": "Revert the candidate configuration to the current\nrunning configuration.",
        "summary": "POST - Controller - ietf-netconf - discard-changes",
        "requestBody": {
          "description": "discard-changes_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC discard-changes success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:cancel-commit": {
      "post": {
        "description": "This operation is used to cancel an ongoing confirmed commit.\nIf the confirmed commit is persistent, the parameter\n'persist-id' must be given, and it must match the value of the\n'persist' parameter.",
        "summary": "POST - Controller - ietf-netconf - cancel-commit",
        "requestBody": {
          "description": "cancel-commit_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_cancel-commit_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_cancel-commit_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC cancel-commit success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf:validate": {
      "post": {
        "description": "Validates the contents of the specified configuration.",
        "summary": "POST - Controller - ietf-netconf - validate",
        "requestBody": {
          "description": "validate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf_validate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf_validate_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC validate success"
          }
        },
        "tags": [
          "Controller ietf-netconf"
        ],
        "parameters": []
      }
    },
    "/rests/data/ietf-netconf-acm:nacm": {
      "post": {
        "description": "Parameters for NETCONF access control model.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-acm - nacm",
        "requestBody": {
          "description": "groups",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "groups": {
                    "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "put": {
        "description": "Parameters for NETCONF access control model.",
        "summary": "PUT - ietf-netconf-acm - Controller - nacm",
        "requestBody": {
          "description": "nacm",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:nacm": {
                    "$ref": "#/components/schemas/ietf-netconf-acm_nacm",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "patch": {
        "description": "Parameters for NETCONF access control model.",
        "summary": "PATCH - ietf-netconf-acm - Controller - nacm",
        "requestBody": {
          "description": "nacm",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:nacm": {
                    "$ref": "#/components/schemas/ietf-netconf-acm_nacm",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "delete": {
        "description": "Parameters for NETCONF access control model.",
        "summary": "DELETE - Controller - ietf-netconf-acm - nacm",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "get": {
        "description": "Parameters for NETCONF access control model.",
        "summary": "GET - Controller - ietf-netconf-acm - nacm",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-acm_nacm"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "nacm": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-acm:nacm/groups": {
      "post": {
        "description": "NETCONF access control groups.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-acm - groups",
        "requestBody": {
          "description": "group",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "group": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "put": {
        "description": "NETCONF access control groups.",
        "summary": "PUT - ietf-netconf-acm - Controller - groups",
        "requestBody": {
          "description": "groups",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:groups": {
                    "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "patch": {
        "description": "NETCONF access control groups.",
        "summary": "PATCH - ietf-netconf-acm - Controller - groups",
        "requestBody": {
          "description": "groups",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:groups": {
                    "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "delete": {
        "description": "NETCONF access control groups.",
        "summary": "DELETE - Controller - ietf-netconf-acm - groups",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": []
      },
      "get": {
        "description": "NETCONF access control groups.",
        "summary": "GET - Controller - ietf-netconf-acm - groups",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "groups": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-acm:nacm/groups/group={name}": {
      "put": {
        "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "summary": "PUT - ietf-netconf-acm - Controller - group",
        "requestBody": {
          "description": "group",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:group": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Group name associated with this entry."
          }
        ]
      },
      "patch": {
        "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "summary": "PATCH - ietf-netconf-acm - Controller - group",
        "requestBody": {
          "description": "group",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:group": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Group name associated with this entry."
          }
        ]
      },
      "delete": {
        "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "summary": "DELETE - Controller - ietf-netconf-acm - group",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Group name associated with this entry."
          }
        ]
      },
      "get": {
        "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "summary": "GET - Controller - ietf-netconf-acm - group",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "group": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Group name associated with this entry."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-acm:nacm/rule-list={name}": {
      "put": {
        "description": "An ordered collection of access control rules.",
        "summary": "PUT - ietf-netconf-acm - Controller - rule-list",
        "requestBody": {
          "description": "rule-list",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:rule-list": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          }
        ]
      },
      "patch": {
        "description": "An ordered collection of access control rules.",
        "summary": "PATCH - ietf-netconf-acm - Controller - rule-list",
        "requestBody": {
          "description": "rule-list",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:rule-list": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          }
        ]
      },
      "delete": {
        "description": "An ordered collection of access control rules.",
        "summary": "DELETE - Controller - ietf-netconf-acm - rule-list",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          }
        ]
      },
      "get": {
        "description": "An ordered collection of access control rules.",
        "summary": "GET - Controller - ietf-netconf-acm - rule-list",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "rule-list": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-acm:nacm/rule-list={name}/rule={name1}": {
      "put": {
        "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted.",
        "summary": "PUT - ietf-netconf-acm - Controller - rule",
        "requestBody": {
          "description": "rule",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:rule": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule."
          }
        ]
      },
      "patch": {
        "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted.",
        "summary": "PATCH - ietf-netconf-acm - Controller - rule",
        "requestBody": {
          "description": "rule",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-acm:rule": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule."
          }
        ]
      },
      "delete": {
        "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted.",
        "summary": "DELETE - Controller - ietf-netconf-acm - rule",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule."
          }
        ]
      },
      "get": {
        "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted.",
        "summary": "GET - Controller - ietf-netconf-acm - rule",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "rule": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-acm"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule-list."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Arbitrary name assigned to the rule."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client": {
      "post": {
        "description": "Top-level container for NETCONF client configuration.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-client - netconf-client",
        "requestBody": {
          "description": "initiate",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "initiate": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "put": {
        "description": "Top-level container for NETCONF client configuration.",
        "summary": "PUT - ietf-netconf-client - Controller - netconf-client",
        "requestBody": {
          "description": "netconf-client",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:netconf-client": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "patch": {
        "description": "Top-level container for NETCONF client configuration.",
        "summary": "PATCH - ietf-netconf-client - Controller - netconf-client",
        "requestBody": {
          "description": "netconf-client",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:netconf-client": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "delete": {
        "description": "Top-level container for NETCONF client configuration.",
        "summary": "DELETE - Controller - ietf-netconf-client - netconf-client",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "get": {
        "description": "Top-level container for NETCONF client configuration.",
        "summary": "GET - Controller - ietf-netconf-client - netconf-client",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "netconf-client": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate": {
      "post": {
        "description": "Configures client initiating underlying TCP connections.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-client - initiate",
        "requestBody": {
          "description": "netconf-server",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-server": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "put": {
        "description": "Configures client initiating underlying TCP connections.",
        "summary": "PUT - ietf-netconf-client - Controller - initiate",
        "requestBody": {
          "description": "initiate",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:initiate": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "patch": {
        "description": "Configures client initiating underlying TCP connections.",
        "summary": "PATCH - ietf-netconf-client - Controller - initiate",
        "requestBody": {
          "description": "initiate",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:initiate": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "delete": {
        "description": "Configures client initiating underlying TCP connections.",
        "summary": "DELETE - Controller - ietf-netconf-client - initiate",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "get": {
        "description": "Configures client initiating underlying TCP connections.",
        "summary": "GET - Controller - ietf-netconf-client - initiate",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "initiate": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate/netconf-server={name}": {
      "put": {
        "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
        "summary": "PUT - ietf-netconf-client - Controller - netconf-server",
        "requestBody": {
          "description": "netconf-server",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:netconf-server": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "patch": {
        "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
        "summary": "PATCH - ietf-netconf-client - Controller - netconf-server",
        "requestBody": {
          "description": "netconf-server",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:netconf-server": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "delete": {
        "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
        "summary": "DELETE - Controller - ietf-netconf-client - netconf-server",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "get": {
        "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
        "summary": "GET - Controller - ietf-netconf-client - netconf-server",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "netconf-server": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate/netconf-server={name}/endpoints": {
      "post": {
        "description": "Container for the list of endpoints.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-client - endpoints",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "put": {
        "description": "Container for the list of endpoints.",
        "summary": "PUT - ietf-netconf-client - Controller - endpoints",
        "requestBody": {
          "description": "endpoints",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoints": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "patch": {
        "description": "Container for the list of endpoints.",
        "summary": "PATCH - ietf-netconf-client - Controller - endpoints",
        "requestBody": {
          "description": "endpoints",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoints": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "delete": {
        "description": "Container for the list of endpoints.",
        "summary": "DELETE - Controller - ietf-netconf-client - endpoints",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "get": {
        "description": "Container for the list of endpoints.",
        "summary": "GET - Controller - ietf-netconf-client - endpoints",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "endpoints": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate/netconf-server={name}/endpoints/endpoint={name1}": {
      "put": {
        "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
        "summary": "PUT - ietf-netconf-client - Controller - endpoint",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the endpoint."
          }
        ]
      },
      "patch": {
        "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
        "summary": "PATCH - ietf-netconf-client - Controller - endpoint",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the endpoint."
          }
        ]
      },
      "delete": {
        "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
        "summary": "DELETE - Controller - ietf-netconf-client - endpoint",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the endpoint."
          }
        ]
      },
      "get": {
        "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
        "summary": "GET - Controller - ietf-netconf-client - endpoint",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "endpoint": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the endpoint."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate/netconf-server={name}/connection-type": {
      "put": {
        "description": "Indicates the NETCONF client's preference for how the\nNETCONF connection is maintained.",
        "summary": "PUT - ietf-netconf-client - Controller - connection-type",
        "requestBody": {
          "description": "connection-type",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:connection-type": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "patch": {
        "description": "Indicates the NETCONF client's preference for how the\nNETCONF connection is maintained.",
        "summary": "PATCH - ietf-netconf-client - Controller - connection-type",
        "requestBody": {
          "description": "connection-type",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:connection-type": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "delete": {
        "description": "Indicates the NETCONF client's preference for how the\nNETCONF connection is maintained.",
        "summary": "DELETE - Controller - ietf-netconf-client - connection-type",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "get": {
        "description": "Indicates the NETCONF client's preference for how the\nNETCONF connection is maintained.",
        "summary": "GET - Controller - ietf-netconf-client - connection-type",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "connection-type": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/initiate/netconf-server={name}/reconnect-strategy": {
      "put": {
        "description": "The reconnection strategy directs how a NETCONF client\nreconnects to a NETCONF server, after discovering its\nconnection to the server has dropped, even if due to a\nreboot.  The NETCONF client starts with the specified\nendpoint and tries to connect to it max-attempts times\nbefore trying the next endpoint in the list (round\nrobin).",
        "summary": "PUT - ietf-netconf-client - Controller - reconnect-strategy",
        "requestBody": {
          "description": "reconnect-strategy",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:reconnect-strategy": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "patch": {
        "description": "The reconnection strategy directs how a NETCONF client\nreconnects to a NETCONF server, after discovering its\nconnection to the server has dropped, even if due to a\nreboot.  The NETCONF client starts with the specified\nendpoint and tries to connect to it max-attempts times\nbefore trying the next endpoint in the list (round\nrobin).",
        "summary": "PATCH - ietf-netconf-client - Controller - reconnect-strategy",
        "requestBody": {
          "description": "reconnect-strategy",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:reconnect-strategy": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "delete": {
        "description": "The reconnection strategy directs how a NETCONF client\nreconnects to a NETCONF server, after discovering its\nconnection to the server has dropped, even if due to a\nreboot.  The NETCONF client starts with the specified\nendpoint and tries to connect to it max-attempts times\nbefore trying the next endpoint in the list (round\nrobin).",
        "summary": "DELETE - Controller - ietf-netconf-client - reconnect-strategy",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          }
        ]
      },
      "get": {
        "description": "The reconnection strategy directs how a NETCONF client\nreconnects to a NETCONF server, after discovering its\nconnection to the server has dropped, even if due to a\nreboot.  The NETCONF client starts with the specified\nendpoint and tries to connect to it max-attempts times\nbefore trying the next endpoint in the list (round\nrobin).",
        "summary": "GET - Controller - ietf-netconf-client - reconnect-strategy",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "reconnect-strategy": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF server."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/listen": {
      "post": {
        "description": "Configures the client to accept call-home TCP connections.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-client - listen",
        "requestBody": {
          "description": "endpoints",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "endpoints": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "put": {
        "description": "Configures the client to accept call-home TCP connections.",
        "summary": "PUT - ietf-netconf-client - Controller - listen",
        "requestBody": {
          "description": "listen",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:listen": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "patch": {
        "description": "Configures the client to accept call-home TCP connections.",
        "summary": "PATCH - ietf-netconf-client - Controller - listen",
        "requestBody": {
          "description": "listen",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:listen": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "delete": {
        "description": "Configures the client to accept call-home TCP connections.",
        "summary": "DELETE - Controller - ietf-netconf-client - listen",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "get": {
        "description": "Configures the client to accept call-home TCP connections.",
        "summary": "GET - Controller - ietf-netconf-client - listen",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "listen": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/listen/endpoints": {
      "post": {
        "description": "Container for a list of endpoints.\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - ietf-netconf-client - endpoints",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "put": {
        "description": "Container for a list of endpoints.",
        "summary": "PUT - ietf-netconf-client - Controller - endpoints",
        "requestBody": {
          "description": "endpoints",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoints": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "patch": {
        "description": "Container for a list of endpoints.",
        "summary": "PATCH - ietf-netconf-client - Controller - endpoints",
        "requestBody": {
          "description": "endpoints",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoints": {
                    "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "delete": {
        "description": "Container for a list of endpoints.",
        "summary": "DELETE - Controller - ietf-netconf-client - endpoints",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": []
      },
      "get": {
        "description": "Container for a list of endpoints.",
        "summary": "GET - Controller - ietf-netconf-client - endpoints",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "endpoints": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-client:netconf-client/listen/endpoints/endpoint={name}": {
      "put": {
        "description": "List of endpoints to listen for NETCONF connections.",
        "summary": "PUT - ietf-netconf-client - Controller - endpoint",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF listen endpoint."
          }
        ]
      },
      "patch": {
        "description": "List of endpoints to listen for NETCONF connections.",
        "summary": "PATCH - ietf-netconf-client - Controller - endpoint",
        "requestBody": {
          "description": "endpoint",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "ietf-netconf-client:endpoint": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF listen endpoint."
          }
        ]
      },
      "delete": {
        "description": "List of endpoints to listen for NETCONF connections.",
        "summary": "DELETE - Controller - ietf-netconf-client - endpoint",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF listen endpoint."
          }
        ]
      },
      "get": {
        "description": "List of endpoints to listen for NETCONF connections.",
        "summary": "GET - Controller - ietf-netconf-client - endpoint",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "endpoint": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-client"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name for the NETCONF listen endpoint."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/ietf-netconf-monitoring:get-schema": {
      "post": {
        "description": "This operation is used to retrieve a schema from the\nNETCONF server.\n\nPositive Response:\nThe NETCONF server returns the requested schema.\n\nNegative Response:\nIf requested schema does not exist, the <error-tag> is\n'invalid-value'.\n\nIf more than one schema matches the requested parameters, the\n<error-tag> is 'operation-failed', and <error-app-tag> is\n'data-not-unique'.",
        "summary": "POST - Controller - ietf-netconf-monitoring - get-schema",
        "requestBody": {
          "description": "get-schema_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf-monitoring_get-schema_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-monitoring_get-schema_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-schema success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_get-schema_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_get-schema_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": []
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state": {
      "get": {
        "description": "The netconf-state container is the root of the monitoring\ndata model.",
        "summary": "GET - Controller - ietf-netconf-monitoring - netconf-state",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "netconf-state": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/capabilities": {
      "get": {
        "description": "Contains the list of NETCONF capabilities supported by the\nserver.",
        "summary": "GET - Controller - ietf-netconf-monitoring - capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "capabilities": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/datastores": {
      "get": {
        "description": "Contains the list of NETCONF configuration datastores.",
        "summary": "GET - Controller - ietf-netconf-monitoring - datastores",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "datastores": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/datastores/datastore={name}": {
      "get": {
        "description": "List of NETCONF configuration datastores supported by\nthe NETCONF server and related information.",
        "summary": "GET - Controller - ietf-netconf-monitoring - datastore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "datastore": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the datastore associated with this list entry."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/datastores/datastore={name}/locks": {
      "get": {
        "description": "The NETCONF <lock> and <partial-lock> operations allow\na client to lock specific resources in a datastore.  The\nNETCONF server will prevent changes to the locked\nresources by all sessions except the one that acquired\nthe lock(s).\n\nMonitoring information is provided for each datastore\nentry including details such as the session that acquired\nthe lock, the type of lock (global or partial) and the\nlist of locked resources.  Multiple locks per datastore\nare supported.",
        "summary": "GET - Controller - ietf-netconf-monitoring - locks",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore_locks"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "locks": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore_locks",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Name of the datastore associated with this list entry."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/schemas": {
      "get": {
        "description": "Contains the list of data model schemas supported by the\nserver.",
        "summary": "GET - Controller - ietf-netconf-monitoring - schemas",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "schemas": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/schemas/schema={identifier},{version},{format}": {
      "get": {
        "description": "List of data model schemas supported by the server.",
        "summary": "GET - Controller - ietf-netconf-monitoring - schema",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas_schema"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "schema": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas_schema",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead."
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present."
          },
          {
            "name": "format",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/sessions": {
      "get": {
        "description": "The sessions container includes session-specific data for\nNETCONF management sessions.  The session list MUST include\nall currently active NETCONF sessions.",
        "summary": "GET - Controller - ietf-netconf-monitoring - sessions",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "sessions": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/sessions/session={session-id}": {
      "get": {
        "description": "All NETCONF sessions managed by the NETCONF server\nMUST be reported in this list.",
        "summary": "GET - Controller - ietf-netconf-monitoring - session",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions_session"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "session": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions_session",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "session-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer"
            },
            "description": "Unique identifier for the session.  This value is the\nNETCONF session identifier, as defined in RFC 4741."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-netconf-monitoring:netconf-state/statistics": {
      "get": {
        "description": "Statistical data pertaining to the NETCONF server.",
        "summary": "GET - Controller - ietf-netconf-monitoring - statistics",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_statistics"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "statistics": {
                      "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_statistics",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/ietf-netconf-nmda:get-data": {
      "post": {
        "description": "Retrieve data from an NMDA datastore.  The content returned\nby get-data must satisfy all filters, i.e., the filter\ncriteria are logically ANDed.\n\nAny ancestor nodes (including list keys) of nodes selected by\nthe filters are included in the response.\n\nThe 'with-origin' parameter is only valid for an operational\ndatastore.  If 'with-origin' is used with an invalid\ndatastore, then the server MUST return an <rpc-error> element\nwith an <error-tag> value of 'invalid-value'.\n\nThe 'with-defaults' parameter only applies to the operational\ndatastore if the NETCONF :with-defaults and\n:with-operational-defaults capabilities are both advertised.\nIf the 'with-defaults' parameter is present in a request for\nwhich it is not supported, then the server MUST return an\n<rpc-error> element with an <error-tag> value of\n'invalid-value'.",
        "summary": "POST - Controller - ietf-netconf-nmda - get-data",
        "requestBody": {
          "description": "get-data_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf-nmda_get-data_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-nmda_get-data_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-data success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-nmda_get-data_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-netconf-nmda_get-data_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-netconf-nmda"
        ],
        "parameters": []
      }
    },
    "/rests/operations/ietf-netconf-nmda:edit-data": {
      "post": {
        "description": "Edit data in an NMDA datastore.\n\nIf an error condition occurs such that an error severity\n<rpc-error> element is generated, the server will stop\nprocessing the <edit-data> operation and restore the\nspecified configuration to its complete state at\nthe start of this <edit-data> operation.",
        "summary": "POST - Controller - ietf-netconf-nmda - edit-data",
        "requestBody": {
          "description": "edit-data_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/ietf-netconf-nmda_edit-data_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/ietf-netconf-nmda_edit-data_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC edit-data success"
          }
        },
        "tags": [
          "Controller ietf-netconf-nmda"
        ],
        "parameters": []
      }
    },
    "/rests/data/ietf-restconf-monitoring:restconf-state": {
      "get": {
        "description": "Contains RESTCONF protocol monitoring information.",
        "summary": "GET - Controller - ietf-restconf-monitoring - restconf-state",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "restconf-state": {
                      "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-restconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-restconf-monitoring:restconf-state/capabilities": {
      "get": {
        "description": "Contains a list of protocol capability URIs.",
        "summary": "GET - Controller - ietf-restconf-monitoring - capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "capabilities": {
                      "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-restconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-restconf-monitoring:restconf-state/streams": {
      "get": {
        "description": "Container representing the notification event streams\nsupported by the server.",
        "summary": "GET - Controller - ietf-restconf-monitoring - streams",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "streams": {
                      "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-restconf-monitoring"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-restconf-monitoring:restconf-state/streams/stream={name}": {
      "get": {
        "description": "Each entry describes an event stream supported by\nthe server.",
        "summary": "GET - Controller - ietf-restconf-monitoring - stream",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "stream": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-restconf-monitoring"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The stream name."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-restconf-monitoring:restconf-state/streams/stream={name}/access={encoding}": {
      "get": {
        "description": "The server will create an entry in this list for each\nencoding format that is supported for this stream.\nThe media type 'text/event-stream' is expected\nfor all event streams.  This list identifies the\nsubtypes supported for this stream.",
        "summary": "GET - Controller - ietf-restconf-monitoring - access",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream_access"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "access": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream_access",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-restconf-monitoring"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The stream name."
          },
          {
            "name": "encoding",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "This is the secondary encoding format within the\n'text/event-stream' encoding used by all streams.\nThe type 'xml' is supported for XML encoding.\nThe type 'json' is supported for JSON encoding."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library": {
      "get": {
        "description": "Container holding the entire YANG library of this server.",
        "summary": "GET - Controller - ietf-yang-library - yang-library",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "yang-library": {
                      "$ref": "#/components/schemas/ietf-yang-library_yang-library",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/module-set={name}": {
      "get": {
        "description": "A set of modules that may be used by one or more schemas.\n\nA module set does not have to be referentially complete,\ni.e., it may define modules that contain import statements\nfor other modules not included in the module set.",
        "summary": "GET - Controller - ietf-yang-library - module-set",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "module-set": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the module set."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/module-set={name}/module={name1}": {
      "get": {
        "description": "An entry in this list represents a module implemented by the\nserver, as per Section 5.6.5 of RFC 7950, with a particular\nset of supported features and deviations.",
        "summary": "GET - Controller - ietf-yang-library - module",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "module": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the module set."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/module-set={name}/module={name1}/submodule={name2}": {
      "get": {
        "description": "Each entry represents one submodule within the\nparent module.",
        "summary": "GET - Controller - ietf-yang-library - submodule",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module_submodule"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "submodule": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module_submodule",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the module set."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "name2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/module-set={name}/import-only-module={name1},{revision}": {
      "get": {
        "description": "An entry in this list indicates that the server imports\nreusable definitions from the specified revision of the\nmodule but does not implement any protocol-accessible\nobjects from this revision.\n\nMultiple entries for the same module name MAY exist.  This\ncan occur if multiple modules import the same module but\nspecify different revision dates in the import statements.",
        "summary": "GET - Controller - ietf-yang-library - import-only-module",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "import-only-module": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the module set."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module name."
          },
          {
            "name": "revision",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/module-set={name}/import-only-module={name1},{revision}/submodule={name2}": {
      "get": {
        "description": "Each entry represents one submodule within the\nparent module.",
        "summary": "GET - Controller - ietf-yang-library - submodule",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module_submodule"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "submodule": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module_submodule",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the module set."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module name."
          },
          {
            "name": "revision",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module."
          },
          {
            "name": "name2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/schema={name}": {
      "get": {
        "description": "A datastore schema that may be used by one or more\ndatastores.\n\nThe schema must be valid and referentially complete, i.e.,\nit must contain modules to satisfy all used import\nstatements for all modules specified in the schema.",
        "summary": "GET - Controller - ietf-yang-library - schema",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_schema"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "schema": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_schema",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "An arbitrary name of the schema."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:yang-library/datastore={name}": {
      "get": {
        "description": "A datastore supported by this server.\n\nEach datastore indicates which schema it supports.\n\nThe server MUST instantiate one entry in this list per\nspecific datastore it supports.\nEach datastore entry with the same datastore schema SHOULD\nreference the same schema.",
        "summary": "GET - Controller - ietf-yang-library - datastore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_yang-library_datastore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "datastore": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_yang-library_datastore",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identity of the datastore."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:modules-state": {
      "get": {
        "description": "Contains YANG module monitoring information.",
        "summary": "GET - Controller - ietf-yang-library - modules-state",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_modules-state"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "modules-state": {
                      "$ref": "#/components/schemas/ietf-yang-library_modules-state",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:modules-state/module={name},{revision}": {
      "get": {
        "description": "Each entry represents one revision of one module\ncurrently supported by the server.",
        "summary": "GET - Controller - ietf-yang-library - module",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_modules-state_module"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "module": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_modules-state_module",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "revision",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:modules-state/module={name},{revision}/deviation={name1},{revision2}": {
      "get": {
        "description": "List of YANG deviation module names and revisions\nused by this server to modify the conformance of\nthe module associated with this entry.  Note that\nthe same module can be used for deviations for\nmultiple modules, so the same entry MAY appear\nwithin multiple 'module' entries.\n\nThe deviation module MUST be present in the 'module'\nlist, with the same name and revision values.\nThe 'conformance-type' value will be 'implement' for\nthe deviation module.",
        "summary": "GET - Controller - ietf-yang-library - deviation",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_deviation"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "deviation": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_deviation",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "revision",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "revision2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/ietf-yang-library:modules-state/module={name},{revision}/submodule={name1},{revision2}": {
      "get": {
        "description": "Each entry represents one submodule within the\nparent module.",
        "summary": "GET - Controller - ietf-yang-library - submodule",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_submodule"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "submodule": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_submodule",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller ietf-yang-library"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "revision",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule."
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule name."
          },
          {
            "name": "revision2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/instance-identifier-patch-module:patch-cont": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - instance-identifier-patch-module - patch-cont",
        "requestBody": {
          "description": "patch-cont2",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "patch-cont2": {
                    "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - instance-identifier-patch-module - Controller - patch-cont",
        "requestBody": {
          "description": "patch-cont",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:patch-cont": {
                    "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - instance-identifier-patch-module - Controller - patch-cont",
        "requestBody": {
          "description": "patch-cont",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:patch-cont": {
                    "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - instance-identifier-patch-module - patch-cont",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - instance-identifier-patch-module - patch-cont",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "patch-cont": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/instance-identifier-patch-module:patch-cont/patch-cont2": {
      "put": {
        "description": "",
        "summary": "PUT - instance-identifier-patch-module - Controller - patch-cont2",
        "requestBody": {
          "description": "patch-cont2",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:patch-cont2": {
                    "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - instance-identifier-patch-module - Controller - patch-cont2",
        "requestBody": {
          "description": "patch-cont2",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:patch-cont2": {
                    "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - instance-identifier-patch-module - patch-cont2",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - instance-identifier-patch-module - patch-cont2",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "patch-cont2": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/instance-identifier-patch-module:patch-cont/my-list1={name}": {
      "put": {
        "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1",
        "summary": "PUT - instance-identifier-patch-module - Controller - my-list1",
        "requestBody": {
          "description": "my-list1",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:my-list1": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1",
        "summary": "PATCH - instance-identifier-patch-module - Controller - my-list1",
        "requestBody": {
          "description": "my-list1",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:my-list1": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1",
        "summary": "DELETE - Controller - instance-identifier-patch-module - my-list1",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1",
        "summary": "GET - Controller - instance-identifier-patch-module - my-list1",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "my-list1": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/instance-identifier-patch-module:patch-cont/my-list1={name}/my-list2={name1}": {
      "put": {
        "description": "",
        "summary": "PUT - instance-identifier-patch-module - Controller - my-list2",
        "requestBody": {
          "description": "my-list2",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:my-list2": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - instance-identifier-patch-module - Controller - my-list2",
        "requestBody": {
          "description": "my-list2",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "instance-identifier-patch-module:my-list2": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - instance-identifier-patch-module - my-list2",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - instance-identifier-patch-module - my-list2",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "my-list2": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller instance-identifier-patch-module"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "name1",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/nc-notifications:netconf": {
      "get": {
        "description": "Top-level element in the notification namespace",
        "summary": "GET - Controller - nc-notifications - netconf",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/nc-notifications_netconf"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "netconf": {
                      "$ref": "#/components/schemas/nc-notifications_netconf",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller nc-notifications"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/nc-notifications:netconf/streams": {
      "get": {
        "description": "The list of event streams supported by the system. When\na query is issued, the returned set of streams is\ndetermined based on user privileges.",
        "summary": "GET - Controller - nc-notifications - streams",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/nc-notifications_netconf_streams"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "streams": {
                      "$ref": "#/components/schemas/nc-notifications_netconf_streams",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller nc-notifications"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/nc-notifications:netconf/streams/stream={name}": {
      "get": {
        "description": "Stream name, description and other information.",
        "summary": "GET - Controller - nc-notifications - stream",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/nc-notifications_netconf_streams_stream"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "stream": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/nc-notifications_netconf_streams_stream",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller nc-notifications"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The name of the event stream. If this is the default\nNETCONF stream, this must have the value 'NETCONF'."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/netconf-keystore:add-keystore-entry": {
      "post": {
        "description": "Use this rpc to add a single or multiple new keys into the keystore. The private key and passphrase\nwill both be encrypted before they are written into the data store.",
        "summary": "POST - Controller - netconf-keystore - add-keystore-entry",
        "requestBody": {
          "description": "add-keystore-entry_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_add-keystore-entry_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_add-keystore-entry_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC add-keystore-entry success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-keystore:remove-keystore-entry": {
      "post": {
        "description": "Use this rpc to remove a single or multiple keys from the data store.",
        "summary": "POST - Controller - netconf-keystore - remove-keystore-entry",
        "requestBody": {
          "description": "remove-keystore-entry_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_remove-keystore-entry_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_remove-keystore-entry_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC remove-keystore-entry success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-keystore:add-private-key": {
      "post": {
        "description": "Add a list of private keys into the keystore.",
        "summary": "POST - Controller - netconf-keystore - add-private-key",
        "requestBody": {
          "description": "add-private-key_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_add-private-key_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_add-private-key_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC add-private-key success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-keystore:remove-private-key": {
      "post": {
        "description": "Remove a list of private keys from the data store.",
        "summary": "POST - Controller - netconf-keystore - remove-private-key",
        "requestBody": {
          "description": "remove-private-key_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_remove-private-key_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_remove-private-key_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC remove-private-key success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-keystore:add-trusted-certificate": {
      "post": {
        "description": "Add a list of trusted certificates into the keystore.",
        "summary": "POST - Controller - netconf-keystore - add-trusted-certificate",
        "requestBody": {
          "description": "add-trusted-certificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_add-trusted-certificate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_add-trusted-certificate_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC add-trusted-certificate success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-keystore:remove-trusted-certificate": {
      "post": {
        "description": "Remove a list of trusted certificates from the data store.",
        "summary": "POST - Controller - netconf-keystore - remove-trusted-certificate",
        "requestBody": {
          "description": "remove-trusted-certificate_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-keystore_remove-trusted-certificate_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_remove-trusted-certificate_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC remove-trusted-certificate success"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      }
    },
    "/rests/data/netconf-keystore:keystore": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - netconf-keystore - keystore",
        "requestBody": {
          "description": "key-credential",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "key-credential": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - netconf-keystore - Controller - keystore",
        "requestBody": {
          "description": "keystore",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-keystore:keystore": {
                    "$ref": "#/components/schemas/netconf-keystore_keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - netconf-keystore - Controller - keystore",
        "requestBody": {
          "description": "keystore",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-keystore:keystore": {
                    "$ref": "#/components/schemas/netconf-keystore_keystore",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - netconf-keystore - keystore",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - netconf-keystore - keystore",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/netconf-keystore_keystore"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "keystore": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/netconf-keystore:keystore/key-credential={key-id}": {
      "put": {
        "description": "",
        "summary": "PUT - netconf-keystore - Controller - key-credential",
        "requestBody": {
          "description": "key-credential",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-keystore:key-credential": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "key-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - netconf-keystore - Controller - key-credential",
        "requestBody": {
          "description": "key-credential",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-keystore:key-credential": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "key-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - netconf-keystore - key-credential",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "key-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - netconf-keystore - key-credential",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "key-credential": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "key-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/netconf-keystore:keystore/private-key={name}": {
      "put": {
        "description": "A private key.",
        "summary": "PUT - netconf-keystore - Controller - private-key",
        "requestBody": {
          "description": "private-key",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-keystore:private-key": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_private-key",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_private-key"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "A private key.",
        "summary": "PATCH - netconf-keystore - Controller - private-key",
        "requestBody": {
          "description": "private-key",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-keystore:private-key": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_private-key",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_private-key"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "A private key.",
        "summary": "DELETE - Controller - netconf-keystore - private-key",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "A private key.",
        "summary": "GET - Controller - netconf-keystore - private-key",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/netconf-keystore_keystore_private-key"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "private-key": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/netconf-keystore_keystore_private-key",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/netconf-keystore:keystore/trusted-certificate={name}": {
      "put": {
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "summary": "PUT - netconf-keystore - Controller - trusted-certificate",
        "requestBody": {
          "description": "trusted-certificate",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-keystore:trusted-certificate": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "summary": "PATCH - netconf-keystore - Controller - trusted-certificate",
        "requestBody": {
          "description": "trusted-certificate",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-keystore:trusted-certificate": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "summary": "DELETE - Controller - netconf-keystore - trusted-certificate",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "summary": "GET - Controller - netconf-keystore - trusted-certificate",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "trusted-certificate": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller netconf-keystore"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/netconf-node-topology:create-device": {
      "post": {
        "description": "",
        "summary": "POST - Controller - netconf-node-topology - create-device",
        "requestBody": {
          "description": "create-device_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-node-topology_create-device_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-node-topology_create-device_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC create-device success"
          }
        },
        "tags": [
          "Controller netconf-node-topology"
        ],
        "parameters": []
      }
    },
    "/rests/operations/netconf-node-topology:delete-device": {
      "post": {
        "description": "",
        "summary": "POST - Controller - netconf-node-topology - delete-device",
        "requestBody": {
          "description": "delete-device_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/netconf-node-topology_delete-device_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/netconf-node-topology_delete-device_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC delete-device success"
          }
        },
        "tags": [
          "Controller netconf-node-topology"
        ],
        "parameters": []
      }
    },
    "/rests/data/network-topology:network-topology": {
      "post": {
        "description": "\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - network-topology - network-topology",
        "requestBody": {
          "description": "topology",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "topology": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": []
      },
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - network-topology",
        "requestBody": {
          "description": "network-topology",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:network-topology": {
                    "$ref": "#/components/schemas/network-topology_network-topology",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - network-topology",
        "requestBody": {
          "description": "network-topology",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:network-topology": {
                    "$ref": "#/components/schemas/network-topology_network-topology",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - network-topology",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - network-topology",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "network-topology": {
                      "$ref": "#/components/schemas/network-topology_network-topology",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}": {
      "put": {
        "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n",
        "summary": "PUT - network-topology - Controller - topology",
        "requestBody": {
          "description": "topology",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:topology": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "patch": {
        "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n",
        "summary": "PATCH - network-topology - Controller - topology",
        "requestBody": {
          "description": "topology",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:topology": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "delete": {
        "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n",
        "summary": "DELETE - Controller - network-topology - topology",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "get": {
        "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n",
        "summary": "GET - Controller - network-topology - topology",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "topology": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/topology-types": {
      "post": {
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n\n\nNote:\nIn example payload, you can see only the first data node child of the resource to be created, following the\nguidelines of RFC 8040, which allows us to create only one resource in POST request.\n",
        "summary": "POST - Controller - network-topology - topology-types",
        "requestBody": {
          "description": "topology-netconf",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "topology-netconf": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "put": {
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n",
        "summary": "PUT - network-topology - Controller - topology-types",
        "requestBody": {
          "description": "topology-types",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:topology-types": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "patch": {
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n",
        "summary": "PATCH - network-topology - Controller - topology-types",
        "requestBody": {
          "description": "topology-types",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:topology-types": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "delete": {
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n",
        "summary": "DELETE - Controller - network-topology - topology-types",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "get": {
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n",
        "summary": "GET - Controller - network-topology - topology-types",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "topology-types": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/topology-types/netconf-node-topology:topology-netconf": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - topology-netconf",
        "requestBody": {
          "description": "topology-netconf",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:topology-netconf": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - topology-netconf",
        "requestBody": {
          "description": "topology-netconf",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:topology-netconf": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - topology-netconf",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - topology-netconf",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "topology-netconf": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/underlay-topology={topology-ref}": {
      "put": {
        "description": "Identifies the topology, or topologies, that this topology\nis dependent on.",
        "summary": "PUT - network-topology - Controller - underlay-topology",
        "requestBody": {
          "description": "underlay-topology",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:underlay-topology": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "Identifies the topology, or topologies, that this topology\nis dependent on.",
        "summary": "PATCH - network-topology - Controller - underlay-topology",
        "requestBody": {
          "description": "underlay-topology",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:underlay-topology": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "Identifies the topology, or topologies, that this topology\nis dependent on.",
        "summary": "DELETE - Controller - network-topology - underlay-topology",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "Identifies the topology, or topologies, that this topology\nis dependent on.",
        "summary": "GET - Controller - network-topology - underlay-topology",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "underlay-topology": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}": {
      "put": {
        "description": "The list of network nodes defined for the topology.",
        "summary": "PUT - network-topology - Controller - node",
        "requestBody": {
          "description": "node",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:node": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "The list of network nodes defined for the topology.",
        "summary": "PATCH - network-topology - Controller - node",
        "requestBody": {
          "description": "node",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:node": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "The list of network nodes defined for the topology.",
        "summary": "DELETE - Controller - network-topology - node",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "The list of network nodes defined for the topology.",
        "summary": "GET - Controller - network-topology - node",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "node": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/supporting-node={topology-ref},{node-ref}": {
      "put": {
        "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes.",
        "summary": "PUT - network-topology - Controller - supporting-node",
        "requestBody": {
          "description": "supporting-node",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:supporting-node": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "node-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes.",
        "summary": "PATCH - network-topology - Controller - supporting-node",
        "requestBody": {
          "description": "supporting-node",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:supporting-node": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "node-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes.",
        "summary": "DELETE - Controller - network-topology - supporting-node",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "node-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes.",
        "summary": "GET - Controller - network-topology - supporting-node",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "supporting-node": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "topology-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "node-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/termination-point={tp-id}": {
      "put": {
        "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface.",
        "summary": "PUT - network-topology - Controller - termination-point",
        "requestBody": {
          "description": "termination-point",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:termination-point": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "tp-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface.",
        "summary": "PATCH - network-topology - Controller - termination-point",
        "requestBody": {
          "description": "termination-point",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:termination-point": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "tp-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface.",
        "summary": "DELETE - Controller - network-topology - termination-point",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "tp-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface.",
        "summary": "GET - Controller - network-topology - termination-point",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "termination-point": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "tp-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-optional:ignore-missing-schema-sources": {
      "put": {
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "summary": "PUT - network-topology - Controller - ignore-missing-schema-sources",
        "requestBody": {
          "description": "ignore-missing-schema-sources",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-optional:ignore-missing-schema-sources": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "summary": "PATCH - network-topology - Controller - ignore-missing-schema-sources",
        "requestBody": {
          "description": "ignore-missing-schema-sources",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-optional:ignore-missing-schema-sources": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "summary": "DELETE - Controller - network-topology - ignore-missing-schema-sources",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "summary": "GET - Controller - network-topology - ignore-missing-schema-sources",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "ignore-missing-schema-sources": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:clustered-connection-status": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - clustered-connection-status",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_clustered-connection-status"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "clustered-connection-status": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_clustered-connection-status",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:clustered-connection-status/node-status": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - node-status",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_clustered-connection-status_node-status"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "node-status": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node_clustered-connection-status_node-status",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:available-capabilities": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - available-capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_available-capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "available-capabilities": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_available-capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:available-capabilities/available-capability": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - available-capability",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_available-capabilities_available-capability"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "available-capability": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node_available-capabilities_available-capability",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:unavailable-capabilities": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - unavailable-capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_unavailable-capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "unavailable-capabilities": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_unavailable-capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:unavailable-capabilities/unavailable-capability": {
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - unavailable-capability",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_unavailable-capabilities_unavailable-capability"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "unavailable-capability": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_node_unavailable-capabilities_unavailable-capability",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:pass-through": {
      "put": {
        "description": "When the underlying node is connected, its NETCONF context\nis available verbatim under this container through the\nmount extension.",
        "summary": "PUT - network-topology - Controller - pass-through",
        "requestBody": {
          "description": "pass-through",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:pass-through": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "When the underlying node is connected, its NETCONF context\nis available verbatim under this container through the\nmount extension.",
        "summary": "PATCH - network-topology - Controller - pass-through",
        "requestBody": {
          "description": "pass-through",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:pass-through": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "When the underlying node is connected, its NETCONF context\nis available verbatim under this container through the\nmount extension.",
        "summary": "DELETE - Controller - network-topology - pass-through",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "When the underlying node is connected, its NETCONF context\nis available verbatim under this container through the\nmount extension.",
        "summary": "GET - Controller - network-topology - pass-through",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "pass-through": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:yang-library": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - yang-library",
        "requestBody": {
          "description": "yang-library",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:yang-library": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - yang-library",
        "requestBody": {
          "description": "yang-library",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:yang-library": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - yang-library",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - yang-library",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "yang-library": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:protocol": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - protocol",
        "requestBody": {
          "description": "protocol",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:protocol": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - protocol",
        "requestBody": {
          "description": "protocol",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:protocol": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - protocol",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - protocol",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "protocol": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:yang-module-capabilities": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - yang-module-capabilities",
        "requestBody": {
          "description": "yang-module-capabilities",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:yang-module-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - yang-module-capabilities",
        "requestBody": {
          "description": "yang-module-capabilities",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:yang-module-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - yang-module-capabilities",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - yang-module-capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "yang-module-capabilities": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:non-module-capabilities": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - non-module-capabilities",
        "requestBody": {
          "description": "non-module-capabilities",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:non-module-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - non-module-capabilities",
        "requestBody": {
          "description": "non-module-capabilities",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:non-module-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - non-module-capabilities",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - non-module-capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "non-module-capabilities": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/node={node-id}/netconf-node-topology:odl-hello-message-capabilities": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - odl-hello-message-capabilities",
        "requestBody": {
          "description": "odl-hello-message-capabilities",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:odl-hello-message-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - odl-hello-message-capabilities",
        "requestBody": {
          "description": "odl-hello-message-capabilities",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "netconf-node-topology:odl-hello-message-capabilities": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - odl-hello-message-capabilities",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - odl-hello-message-capabilities",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "odl-hello-message-capabilities": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "node-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/link={link-id}": {
      "put": {
        "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n",
        "summary": "PUT - network-topology - Controller - link",
        "requestBody": {
          "description": "link",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:link": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n",
        "summary": "PATCH - network-topology - Controller - link",
        "requestBody": {
          "description": "link",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:link": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n",
        "summary": "DELETE - Controller - network-topology - link",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n",
        "summary": "GET - Controller - network-topology - link",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_link"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "link": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_link",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/link={link-id}/source": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - source",
        "requestBody": {
          "description": "source",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:source": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - source",
        "requestBody": {
          "description": "source",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:source": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - source",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - source",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "source": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/link={link-id}/destination": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - destination",
        "requestBody": {
          "description": "destination",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:destination": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - destination",
        "requestBody": {
          "description": "destination",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:destination": {
                    "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - destination",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - destination",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "destination": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/data/network-topology:network-topology/topology={topology-id}/link={link-id}/supporting-link={link-ref}": {
      "put": {
        "description": "",
        "summary": "PUT - network-topology - Controller - supporting-link",
        "requestBody": {
          "description": "supporting-link",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "network-topology:supporting-link": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "link-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - network-topology - Controller - supporting-link",
        "requestBody": {
          "description": "supporting-link",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "network-topology:supporting-link": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "link-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - network-topology - supporting-link",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "link-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - network-topology - supporting-link",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "supporting-link": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller network-topology"
        ],
        "parameters": [
          {
            "name": "topology-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n"
          },
          {
            "name": "link-id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs."
          },
          {
            "name": "link-ref",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/notifications:create-subscription": {
      "post": {
        "description": "The command to create a notification subscription. It\ntakes as argument the name of the notification stream\nand filter. Both of those options limit the content of\nthe subscription. In addition, there are two time-related\nparameters, startTime and stopTime, which can be used to\nselect the time interval of interest to the notification\nreplay feature.",
        "summary": "POST - Controller - notifications - create-subscription",
        "requestBody": {
          "description": "create-subscription_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/notifications_create-subscription_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/notifications_create-subscription_input"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "RPC create-subscription success"
          }
        },
        "tags": [
          "Controller notifications"
        ],
        "parameters": []
      }
    },
    "/rests/operations/odl-device-notification:subscribe-device-notification": {
      "post": {
        "description": "Subscribe to notifications on specified device.",
        "summary": "POST - Controller - odl-device-notification - subscribe-device-notification",
        "requestBody": {
          "description": "subscribe-device-notification_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/odl-device-notification_subscribe-device-notification_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/odl-device-notification_subscribe-device-notification_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC subscribe-device-notification success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/odl-device-notification_subscribe-device-notification_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/odl-device-notification_subscribe-device-notification_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller odl-device-notification"
        ],
        "parameters": []
      }
    },
    "/rests/operations/odl-entity-owners:get-entities": {
      "post": {
        "description": "",
        "summary": "POST - Controller - odl-entity-owners - get-entities",
        "requestBody": {
          "description": "get-entities_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-entities success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entities_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entities_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller odl-entity-owners"
        ],
        "parameters": []
      }
    },
    "/rests/operations/odl-entity-owners:get-entity": {
      "post": {
        "description": "",
        "summary": "POST - Controller - odl-entity-owners - get-entity",
        "requestBody": {
          "description": "get-entity_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/odl-entity-owners_get-entity_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/odl-entity-owners_get-entity_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-entity success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entity_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entity_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller odl-entity-owners"
        ],
        "parameters": []
      }
    },
    "/rests/operations/odl-entity-owners:get-entity-owner": {
      "post": {
        "description": "",
        "summary": "POST - Controller - odl-entity-owners - get-entity-owner",
        "requestBody": {
          "description": "get-entity-owner_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/odl-entity-owners_get-entity-owner_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/odl-entity-owners_get-entity-owner_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC get-entity-owner success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entity-owner_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/odl-entity-owners_get-entity-owner_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller odl-entity-owners"
        ],
        "parameters": []
      }
    },
    "/rests/data/odl-general-entity:entity={name}": {
      "put": {
        "description": "",
        "summary": "PUT - odl-general-entity - Controller - entity",
        "requestBody": {
          "description": "entity",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "odl-general-entity:entity": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/odl-general-entity_entity",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/odl-general-entity_entity"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller odl-general-entity"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "patch": {
        "description": "",
        "summary": "PATCH - odl-general-entity - Controller - entity",
        "requestBody": {
          "description": "entity",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "odl-general-entity:entity": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/odl-general-entity_entity",
                      "type": "object"
                    }
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/odl-general-entity_entity"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller odl-general-entity"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - odl-general-entity - entity",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller odl-general-entity"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ]
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - odl-general-entity - entity",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/odl-general-entity_entity"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "entity": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/odl-general-entity_entity",
                        "type": "object"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller odl-general-entity"
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    },
    "/rests/operations/sal-remote:create-data-change-event-subscription": {
      "post": {
        "description": "",
        "summary": "POST - Controller - sal-remote - create-data-change-event-subscription",
        "requestBody": {
          "description": "create-data-change-event-subscription_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/sal-remote_create-data-change-event-subscription_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/sal-remote_create-data-change-event-subscription_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC create-data-change-event-subscription success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_create-data-change-event-subscription_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_create-data-change-event-subscription_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller sal-remote"
        ],
        "parameters": []
      }
    },
    "/rests/operations/sal-remote:create-notification-stream": {
      "post": {
        "description": "",
        "summary": "POST - Controller - sal-remote - create-notification-stream",
        "requestBody": {
          "description": "create-notification-stream_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "$ref": "#/components/schemas/sal-remote_create-notification-stream_input",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/sal-remote_create-notification-stream_input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC create-notification-stream success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_create-notification-stream_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_create-notification-stream_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller sal-remote"
        ],
        "parameters": []
      }
    },
    "/rests/operations/sal-remote:begin-transaction": {
      "post": {
        "description": "",
        "summary": "POST - Controller - sal-remote - begin-transaction",
        "requestBody": {
          "description": "begin-transaction_input",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "input": {
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "application/xml": {
              "schema": {
                "xml": {
                  "name": "input",
                  "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
                },
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RPC begin-transaction success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_begin-transaction_output"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/sal-remote_begin-transaction_output"
                }
              }
            }
          }
        },
        "tags": [
          "Controller sal-remote"
        ],
        "parameters": []
      }
    },
    "/rests/data/subscribe-to-notification:notifi": {
      "put": {
        "description": "",
        "summary": "PUT - subscribe-to-notification - Controller - notifi",
        "requestBody": {
          "description": "notifi",
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "subscribe-to-notification:notifi": {
                    "$ref": "#/components/schemas/subscribe-to-notification_notifi",
                    "type": "object"
                  }
                }
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/subscribe-to-notification_notifi"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Created"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller subscribe-to-notification"
        ],
        "parameters": []
      },
      "patch": {
        "description": "",
        "summary": "PATCH - subscribe-to-notification - Controller - notifi",
        "requestBody": {
          "description": "notifi",
          "content": {
            "application/yang-data+json": {
              "schema": {
                "properties": {
                  "subscribe-to-notification:notifi": {
                    "$ref": "#/components/schemas/subscribe-to-notification_notifi",
                    "type": "object"
                  }
                }
              }
            },
            "application/yang-data+xml": {
              "schema": {
                "$ref": "#/components/schemas/subscribe-to-notification_notifi"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "204": {
            "description": "Updated"
          }
        },
        "tags": [
          "Controller subscribe-to-notification"
        ],
        "parameters": []
      },
      "delete": {
        "description": "",
        "summary": "DELETE - Controller - subscribe-to-notification - notifi",
        "responses": {
          "204": {
            "description": "Deleted"
          }
        },
        "tags": [
          "Controller subscribe-to-notification"
        ],
        "parameters": []
      },
      "get": {
        "description": "",
        "summary": "GET - Controller - subscribe-to-notification - notifi",
        "responses": {
          "200": {
            "description": "200",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/subscribe-to-notification_notifi"
                }
              },
              "application/json": {
                "schema": {
                  "properties": {
                    "notifi": {
                      "$ref": "#/components/schemas/subscribe-to-notification_notifi",
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Controller subscribe-to-notification"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "required": false,
            "schema": {
              "enum": [
                "config",
                "nonconfig",
                "all"
              ],
              "type": "string"
            }
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "aaa_authentication": {
        "title": "aaa_authentication",
        "type": "object",
        "properties": {
          "grants": {
            "$ref": "#/components/schemas/aaa_authentication_grants"
          },
          "roles": {
            "$ref": "#/components/schemas/aaa_authentication_roles"
          },
          "domains": {
            "$ref": "#/components/schemas/aaa_authentication_domains"
          },
          "users": {
            "$ref": "#/components/schemas/aaa_authentication_users"
          }
        },
        "xml": {
          "name": "authentication",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_domains": {
        "title": "aaa_authentication_domains",
        "type": "object",
        "properties": {
          "domains": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_authentication_domains_domains"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "domains",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_domains_domains": {
        "title": "aaa_authentication_domains_domains",
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the domain.",
            "type": "string",
            "example": "Some name"
          },
          "description": {
            "description": "A description for the domain;  defaults to the empty string.",
            "type": "string",
            "default": "",
            "example": "Some description"
          },
          "domainid": {
            "description": "An internal wiring detail in the form 'name'.",
            "type": "string",
            "example": "Some domainid"
          }
        },
        "xml": {
          "name": "domains",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_users": {
        "title": "aaa_authentication_users",
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_authentication_users_users"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "users",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_users_users": {
        "title": "aaa_authentication_users_users",
        "type": "object",
        "properties": {
          "password": {
            "description": "A one-way hashed and salted version of the users password.",
            "type": "string",
            "example": "Some password"
          },
          "salt": {
            "description": "A user-specific salt used for password hashing.",
            "type": "string",
            "example": "Some salt"
          },
          "name": {
            "description": "The name of the user.",
            "type": "string",
            "example": "Some name"
          },
          "description": {
            "description": "A description for the user;  defaults to the empty string.",
            "type": "string",
            "default": "",
            "example": "Some description"
          },
          "userid": {
            "description": "An internal wiring detail in the form 'name@domain'.",
            "type": "string",
            "example": "Some userid"
          },
          "enabled": {
            "description": "Whether or not the user is enabled;  defaults to true.",
            "type": "boolean",
            "default": true,
            "example": true
          },
          "email": {
            "description": "An email address for the user;  defaults to the empty string.",
            "type": "string",
            "default": "",
            "example": "Some email"
          },
          "domainid": {
            "description": "The domain to which the user belongs.",
            "type": "string",
            "example": "Some domainid"
          }
        },
        "xml": {
          "name": "users",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_roles": {
        "title": "aaa_authentication_roles",
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_authentication_roles_roles"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "roles",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_roles_roles": {
        "title": "aaa_authentication_roles_roles",
        "type": "object",
        "properties": {
          "roleid": {
            "description": "An internal wiring detail in the form 'name'.",
            "type": "string",
            "example": "Some roleid"
          },
          "name": {
            "description": "The name for the role.",
            "type": "string",
            "example": "Some name"
          },
          "description": {
            "description": "A description of the role;  defaults to the empty string.",
            "type": "string",
            "default": "",
            "example": "Some description"
          },
          "domainid": {
            "description": "The domain associated with the role.",
            "type": "string",
            "example": "Some domainid"
          }
        },
        "xml": {
          "name": "roles",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_grants": {
        "title": "aaa_authentication_grants",
        "type": "object",
        "properties": {
          "grants": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_authentication_grants_grants"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "grants",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_authentication_grants_grants": {
        "title": "aaa_authentication_grants_grants",
        "type": "object",
        "properties": {
          "grantid": {
            "description": "An internal wiring detail in the form 'userid@roleid@domainid'.",
            "type": "string",
            "example": "Some grantid"
          },
          "roleid": {
            "description": "A reference to the role.",
            "type": "string",
            "example": "Some roleid"
          },
          "userid": {
            "description": "A reference to the user.",
            "type": "string",
            "example": "Some userid"
          },
          "domainid": {
            "description": "A reference to the domain.",
            "type": "string",
            "example": "Some domainid"
          }
        },
        "xml": {
          "name": "grants",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_http-authorization": {
        "title": "aaa_http-authorization",
        "type": "object",
        "properties": {
          "policies": {
            "$ref": "#/components/schemas/aaa_http-authorization_policies"
          }
        },
        "xml": {
          "name": "http-authorization",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_http-authorization_policies": {
        "title": "aaa_http-authorization_policies",
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_http-authorization_policies_policies"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "policies",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_http-authorization_policies_policies": {
        "title": "aaa_http-authorization_policies_policies",
        "type": "object",
        "properties": {
          "resource": {
            "description": "",
            "type": "string",
            "default": "*",
            "example": "Some resource"
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa_http-authorization_policies_policies_permissions"
            },
            "description": ""
          },
          "index": {
            "description": "",
            "type": "integer",
            "format": "int64",
            "example": 0
          },
          "description": {
            "description": "",
            "type": "string",
            "default": "",
            "example": "Some description"
          }
        },
        "required": [
          "index"
        ],
        "xml": {
          "name": "policies",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa_http-authorization_policies_policies_permissions": {
        "title": "aaa_http-authorization_policies_policies_permissions",
        "type": "object",
        "properties": {
          "role": {
            "description": "",
            "type": "string",
            "example": "Some role"
          },
          "actions": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "get",
                "put",
                "post",
                "patch",
                "delete"
              ],
              "example": "get"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "permissions",
          "namespace": "urn:opendaylight:params:xml:ns:yang:aaa"
        }
      },
      "aaa-app-config_shiro-configuration": {
        "title": "aaa-app-config_shiro-configuration",
        "type": "object",
        "description": "AAA shiro related configuration.",
        "properties": {
          "urls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_urls"
            },
            "description": "The urls section of shiro.ini."
          },
          "main": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa-app-config_shiro-configuration_main"
            },
            "description": "The main section of shiro.ini."
          }
        },
        "xml": {
          "name": "shiro-configuration",
          "namespace": "urn:opendaylight:aaa:app:config"
        }
      },
      "aaa-app-config_shiro-configuration_main": {
        "title": "aaa-app-config_shiro-configuration_main",
        "type": "object",
        "description": "The main section of shiro.ini.",
        "properties": {
          "pair-key": {
            "description": "The key.",
            "type": "string",
            "example": "Some pair-key"
          },
          "pair-value": {
            "description": "The value.",
            "type": "string",
            "example": "Some pair-value"
          }
        },
        "xml": {
          "name": "main",
          "namespace": "urn:opendaylight:aaa:app:config"
        }
      },
      "aaa-app-config_shiro-configuration_urls": {
        "title": "aaa-app-config_shiro-configuration_urls",
        "type": "object",
        "description": "The urls section of shiro.ini.",
        "properties": {
          "pair-key": {
            "description": "The key.",
            "type": "string",
            "example": "Some pair-key"
          },
          "pair-value": {
            "description": "The value.",
            "type": "string",
            "example": "Some pair-value"
          }
        },
        "xml": {
          "name": "urls",
          "namespace": "urn:opendaylight:aaa:app:config"
        }
      },
      "aaa-app-config_datastore-config": {
        "title": "aaa-app-config_datastore-config",
        "type": "object",
        "properties": {
          "time-to-live": {
            "description": "Time to live for tokens in second.",
            "type": "integer",
            "default": 36000,
            "example": 0
          },
          "time-to-wait": {
            "description": "Time to wait for tokens in second.",
            "type": "integer",
            "default": 3600,
            "example": 0
          },
          "store": {
            "description": "Available data store types.",
            "type": "string",
            "enum": [
              "h2-data-store"
            ],
            "example": "h2-data-store"
          }
        },
        "xml": {
          "name": "datastore-config",
          "namespace": "urn:opendaylight:aaa:app:config"
        }
      },
      "aaa-cert_aaa-cert-service-config": {
        "title": "aaa-cert_aaa-cert-service-config",
        "type": "object",
        "properties": {
          "bundle-name": {
            "description": "bundle name of the default TLS config in MdsaL",
            "type": "string",
            "example": "Some bundle-name"
          },
          "use-config": {
            "description": "Use the configuration data to create the keystores",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "ctlKeystore": {
            "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore"
          },
          "trustKeystore": {
            "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_trustKeystore"
          },
          "use-mdsal": {
            "description": "Use Mdsal as Data store for the keystore and certificates",
            "type": "boolean",
            "default": false,
            "example": true
          }
        },
        "xml": {
          "name": "aaa-cert-service-config",
          "namespace": "urn:opendaylight:yang:aaa:cert"
        }
      },
      "aaa-cert_aaa-cert-service-config_ctlKeystore": {
        "title": "aaa-cert_aaa-cert-service-config_ctlKeystore",
        "type": "object",
        "properties": {
          "sign-alg": {
            "description": "The supported sign algorithmes i.e: SHA1withDSA or SHA1withRSA",
            "type": "string",
            "example": "Some sign-alg"
          },
          "keysize": {
            "description": "the key size i.e: 1024",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "tls-protocols": {
            "description": "the TLS supported protocols SSLv2Hello,TLSv1.1,TLSv1.2",
            "type": "string",
            "example": "Some tls-protocols"
          },
          "cipher-suites": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites"
            },
            "description": ""
          },
          "name": {
            "description": "keystore name default is ctl",
            "type": "string",
            "example": "Some name"
          },
          "alias": {
            "description": "key alias",
            "type": "string",
            "example": "Some alias"
          },
          "dname": {
            "description": "X.500 Distinguished Names should be in the following formate\nCN=commonName\nOU=organizationUnit\nO=organizationName\nL=localityName\nS=stateName\nC=country",
            "type": "string",
            "example": "Some dname"
          },
          "validity": {
            "description": "validity",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "key-alg": {
            "description": "The supported key generation algorithms i.e: DSA or RSA",
            "type": "string",
            "example": "Some key-alg"
          },
          "store-password": {
            "description": "keystore password",
            "type": "string",
            "example": "Some store-password"
          }
        },
        "xml": {
          "name": "ctlKeystore",
          "namespace": "urn:opendaylight:yang:aaa:cert"
        }
      },
      "aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites": {
        "title": "aaa-cert_aaa-cert-service-config_ctlKeystore_cipher-suites",
        "type": "object",
        "properties": {
          "suite-name": {
            "description": "",
            "type": "string",
            "example": "Some suite-name"
          }
        },
        "xml": {
          "name": "cipher-suites",
          "namespace": "urn:opendaylight:yang:aaa:cert"
        }
      },
      "aaa-cert_aaa-cert-service-config_trustKeystore": {
        "title": "aaa-cert_aaa-cert-service-config_trustKeystore",
        "type": "object",
        "properties": {
          "name": {
            "description": "keystore name default is truststore",
            "type": "string",
            "example": "Some name"
          },
          "store-password": {
            "description": "keystore password",
            "type": "string",
            "example": "Some store-password"
          }
        },
        "xml": {
          "name": "trustKeystore",
          "namespace": "urn:opendaylight:yang:aaa:cert"
        }
      },
      "aaa-cert-mdsal_key-stores": {
        "title": "aaa-cert-mdsal_key-stores",
        "type": "object",
        "properties": {
          "ssl-data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data"
            },
            "description": ""
          },
          "id": {
            "description": "",
            "type": "string",
            "example": "Some id"
          }
        },
        "required": [
          "id"
        ],
        "xml": {
          "name": "key-stores",
          "namespace": "urn:opendaylight:yang:aaa:cert:mdsal"
        }
      },
      "aaa-cert-mdsal_key-stores_ssl-data": {
        "title": "aaa-cert-mdsal_key-stores_ssl-data",
        "type": "object",
        "properties": {
          "odl-keystore": {
            "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_odl-keystore"
          },
          "bundle-name": {
            "description": "bundle name",
            "type": "string",
            "example": "Some bundle-name"
          },
          "tls-protocols": {
            "description": "the TLS supported protocols (SSLv2Hello,TLSv1.1,TLSv1.2) the selected protocol should be seperated by ',' char",
            "type": "string",
            "example": "Some tls-protocols"
          },
          "cipher-suites": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_cipher-suites"
            },
            "description": ""
          },
          "trust-keystore": {
            "$ref": "#/components/schemas/aaa-cert-mdsal_key-stores_ssl-data_trust-keystore"
          }
        },
        "required": [
          "bundle-name"
        ],
        "xml": {
          "name": "ssl-data",
          "namespace": "urn:opendaylight:yang:aaa:cert:mdsal"
        }
      },
      "aaa-cert-mdsal_key-stores_ssl-data_odl-keystore": {
        "title": "aaa-cert-mdsal_key-stores_ssl-data_odl-keystore",
        "type": "object",
        "properties": {
          "sign-alg": {
            "description": "supported sign algorithmes for DSA the default sign Alg is SHA1withDSA and for RSA the\ndefault sign Alg is MD5withRSA",
            "type": "string",
            "example": "Some sign-alg"
          },
          "keysize": {
            "description": "key size is 1024 or 2048",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "name": {
            "description": "keystore name",
            "type": "string",
            "example": "Some name"
          },
          "alias": {
            "description": "key alias",
            "type": "string",
            "example": "Some alias"
          },
          "keystoreFile": {
            "description": "keystore file as Binary",
            "type": "string",
            "format": "byte"
          },
          "dname": {
            "description": "X.500 Distinguished Names should be in the following formate\nCN=commonName\nOU=organizationUnit\nO=organizationName\nL=localityName\nS=stateName\nC=country",
            "type": "string",
            "example": "Some dname"
          },
          "validity": {
            "description": "validity",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "key-alg": {
            "description": "supported key geneartion algorithmes are DSA and RSA",
            "type": "string",
            "example": "Some key-alg"
          },
          "store-password": {
            "description": "keystore password",
            "type": "string",
            "example": "Some store-password"
          }
        },
        "xml": {
          "name": "odl-keystore",
          "namespace": "urn:opendaylight:yang:aaa:cert:mdsal"
        }
      },
      "aaa-cert-mdsal_key-stores_ssl-data_trust-keystore": {
        "title": "aaa-cert-mdsal_key-stores_ssl-data_trust-keystore",
        "type": "object",
        "properties": {
          "sign-alg": {
            "description": "supported sign algorithmes for DSA the default sign Alg is SHA1withDSA and for RSA the\ndefault sign Alg is MD5withRSA",
            "type": "string",
            "example": "Some sign-alg"
          },
          "keysize": {
            "description": "key size is 1024 or 2048",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "name": {
            "description": "keystore name",
            "type": "string",
            "example": "Some name"
          },
          "alias": {
            "description": "key alias",
            "type": "string",
            "example": "Some alias"
          },
          "keystoreFile": {
            "description": "keystore file as Binary",
            "type": "string",
            "format": "byte"
          },
          "dname": {
            "description": "X.500 Distinguished Names should be in the following formate\nCN=commonName\nOU=organizationUnit\nO=organizationName\nL=localityName\nS=stateName\nC=country",
            "type": "string",
            "example": "Some dname"
          },
          "validity": {
            "description": "validity",
            "type": "integer",
            "format": "int32",
            "example": -2147483648
          },
          "key-alg": {
            "description": "supported key geneartion algorithmes are DSA and RSA",
            "type": "string",
            "example": "Some key-alg"
          },
          "store-password": {
            "description": "keystore password",
            "type": "string",
            "example": "Some store-password"
          }
        },
        "xml": {
          "name": "trust-keystore",
          "namespace": "urn:opendaylight:yang:aaa:cert:mdsal"
        }
      },
      "aaa-cert-mdsal_key-stores_ssl-data_cipher-suites": {
        "title": "aaa-cert-mdsal_key-stores_ssl-data_cipher-suites",
        "type": "object",
        "properties": {
          "suiteName": {
            "description": "",
            "type": "string",
            "example": "Some suiteName"
          }
        },
        "xml": {
          "name": "cipher-suites",
          "namespace": "urn:opendaylight:yang:aaa:cert:mdsal"
        }
      },
      "aaa-cert-rpc_getODLCertificate_output": {
        "title": "aaa-cert-rpc_getODLCertificate_output",
        "type": "object",
        "properties": {
          "odl-cert": {
            "description": "",
            "type": "string",
            "example": "Some odl-cert"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-cert-rpc_getODLCertificateReq_output": {
        "title": "aaa-cert-rpc_getODLCertificateReq_output",
        "type": "object",
        "properties": {
          "odl-cert-req": {
            "description": "",
            "type": "string",
            "example": "Some odl-cert-req"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-cert-rpc_setODLCertificate_input": {
        "title": "aaa-cert-rpc_setODLCertificate_input",
        "type": "object",
        "properties": {
          "odl-cert-alias": {
            "description": "",
            "type": "string",
            "example": "Some odl-cert-alias"
          },
          "odl-cert": {
            "description": "",
            "type": "string",
            "example": "Some odl-cert"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-cert-rpc_setNodeCertificate_input": {
        "title": "aaa-cert-rpc_setNodeCertificate_input",
        "type": "object",
        "properties": {
          "node-alias": {
            "description": "",
            "type": "string",
            "example": "Some node-alias"
          },
          "node-cert": {
            "description": "",
            "type": "string",
            "example": "Some node-cert"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-cert-rpc_getNodeCertificate_input": {
        "title": "aaa-cert-rpc_getNodeCertificate_input",
        "type": "object",
        "properties": {
          "node-alias": {
            "description": "",
            "type": "string",
            "example": "Some node-alias"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-cert-rpc_getNodeCertificate_output": {
        "title": "aaa-cert-rpc_getNodeCertificate_output",
        "type": "object",
        "properties": {
          "node-cert": {
            "description": "",
            "type": "string",
            "example": "Some node-cert"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:yang:aaa:cert:rpc"
        }
      },
      "aaa-encrypt-service-config_aaa-encrypt-service-config": {
        "title": "aaa-encrypt-service-config_aaa-encrypt-service-config",
        "type": "object",
        "properties": {
          "encrypt-iteration-count": {
            "description": "Number of iterations that will be used by the key",
            "type": "integer",
            "format": "int32",
            "default": 32768,
            "example": -2147483648
          },
          "encrypt-type": {
            "description": "The encryption type",
            "type": "string",
            "default": "AES",
            "example": "Some encrypt-type"
          },
          "password-length": {
            "description": "Encryption key password length",
            "type": "integer",
            "format": "int32",
            "default": 12,
            "example": -2147483648
          },
          "cipher-transforms": {
            "description": "cipher transformation type ex: AES/CBC/PKCS5Padding (128)",
            "type": "string",
            "default": "AES/CBC/PKCS5Padding",
            "example": "Some cipher-transforms"
          },
          "encrypt-key-length": {
            "description": "Key length",
            "type": "integer",
            "format": "int32",
            "default": 128,
            "example": -2147483648
          },
          "encrypt-key": {
            "description": "Encryption key",
            "type": "string",
            "example": "Some encrypt-key"
          },
          "encrypt-salt": {
            "description": "Encryption key salt",
            "type": "string",
            "example": "Some encrypt-salt"
          },
          "encrypt-method": {
            "description": "The encryption method to use",
            "type": "string",
            "default": "PBKDF2WithHmacSHA1",
            "example": "Some encrypt-method"
          }
        },
        "xml": {
          "name": "aaa-encrypt-service-config",
          "namespace": "config:aaa:authn:encrypt:service:config"
        }
      },
      "aaa-password-service-config_password-service-config": {
        "title": "aaa-password-service-config_password-service-config",
        "type": "object",
        "properties": {
          "private-salt": {
            "description": "The private salt for password hashing.",
            "type": "string",
            "example": "Some private-salt"
          },
          "iterations": {
            "description": "The number of times to hash.",
            "type": "integer",
            "format": "int32",
            "default": 20000,
            "example": -2147483648
          },
          "algorithm": {
            "description": "The algorithm utilized for aaa-password-service hashing.",
            "type": "string",
            "default": "SHA-512",
            "example": "Some algorithm"
          }
        },
        "xml": {
          "name": "password-service-config",
          "namespace": "urn:opendaylight:aaa:password:service:config"
        }
      },
      "cluster-admin_add-shard-replica_input": {
        "title": "cluster-admin_add-shard-replica_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          }
        },
        "required": [
          "shard-name",
          "data-store-type"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_remove-shard-replica_input": {
        "title": "cluster-admin_remove-shard-replica_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          },
          "member-name": {
            "description": "The cluster member from which the shard replica should be removed",
            "type": "string",
            "example": "Some member-name"
          }
        },
        "required": [
          "shard-name",
          "data-store-type",
          "member-name"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_make-leader-local_input": {
        "title": "cluster-admin_make-leader-local_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          }
        },
        "required": [
          "shard-name",
          "data-store-type"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_add-replicas-for-all-shards_output": {
        "title": "cluster-admin_add-replicas-for-all-shards_output",
        "type": "object",
        "properties": {
          "shard-result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result"
            },
            "description": "The list of results, one per shard"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_shard-result": {
        "title": "cluster-admin_shard-result",
        "type": "object",
        "description": "The list of results, one per shard",
        "properties": {
          "error-message": {
            "description": "",
            "type": "string",
            "example": "Some error-message"
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          },
          "succeeded": {
            "description": "",
            "type": "boolean",
            "example": true
          },
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          }
        },
        "required": [
          "data-store-type",
          "shard-name"
        ],
        "xml": {
          "name": "shard-result",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_remove-all-shard-replicas_input": {
        "title": "cluster-admin_remove-all-shard-replicas_input",
        "type": "object",
        "properties": {
          "member-name": {
            "description": "The cluster member from which the shard replicas should be removed",
            "type": "string",
            "example": "Some member-name"
          }
        },
        "required": [
          "member-name"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_remove-all-shard-replicas_output": {
        "title": "cluster-admin_remove-all-shard-replicas_output",
        "type": "object",
        "properties": {
          "shard-result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result"
            },
            "description": "The list of results, one per shard"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_change-member-voting-states-for-shard_input": {
        "title": "cluster-admin_change-member-voting-states-for-shard_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          },
          "member-voting-state": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_member-voting-state"
            },
            "description": "The list of member voting states"
          }
        },
        "required": [
          "shard-name",
          "data-store-type"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_member-voting-state": {
        "title": "cluster-admin_member-voting-state",
        "type": "object",
        "description": "The list of member voting states",
        "properties": {
          "member-name": {
            "description": "",
            "type": "string",
            "example": "Some member-name"
          },
          "voting": {
            "description": "",
            "type": "boolean",
            "example": true
          }
        },
        "xml": {
          "name": "member-voting-state",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_change-member-voting-states-for-all-shards_input": {
        "title": "cluster-admin_change-member-voting-states-for-all-shards_input",
        "type": "object",
        "properties": {
          "member-voting-state": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_member-voting-state"
            },
            "description": "The list of member voting states"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_change-member-voting-states-for-all-shards_output": {
        "title": "cluster-admin_change-member-voting-states-for-all-shards_output",
        "type": "object",
        "properties": {
          "shard-result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result"
            },
            "description": "The list of results, one per shard"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_flip-member-voting-states-for-all-shards_output": {
        "title": "cluster-admin_flip-member-voting-states-for-all-shards_output",
        "type": "object",
        "properties": {
          "shard-result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result"
            },
            "description": "The list of results, one per shard"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_backup-datastore_input": {
        "title": "cluster-admin_backup-datastore_input",
        "type": "object",
        "properties": {
          "file-path": {
            "description": "The path and name of the file in which to store the backup.",
            "type": "string",
            "example": "Some file-path"
          },
          "timeout": {
            "description": "Optional timeout in seconds for the backup operation which will override all the different\ntimeouts that are being hit on the backend.",
            "type": "integer",
            "format": "int64",
            "example": 1
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_get-shard-role_input": {
        "title": "cluster-admin_get-shard-role_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          }
        },
        "required": [
          "shard-name",
          "data-store-type"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_get-shard-role_output": {
        "title": "cluster-admin_get-shard-role_output",
        "type": "object",
        "properties": {
          "role": {
            "description": "Current role for the given shard, if not present the shard currently does not have a role",
            "type": "string",
            "example": "Some role"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_locate-shard_input": {
        "title": "cluster-admin_locate-shard_input",
        "type": "object",
        "properties": {
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          }
        },
        "required": [
          "shard-name",
          "data-store-type"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_locate-shard_output": {
        "title": "cluster-admin_locate-shard_output",
        "type": "object",
        "properties": {
          "local": {
            "description": "Local node is the best node to talk to when it comes from efficiency perspective\nof underlying implementation. The requester of this RPC is advised to contact\nany services to the specified shard via the channel on which this RPC was invoked.",
            "type": "object"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_get-known-clients-for-all-shards_output": {
        "title": "cluster-admin_get-known-clients-for-all-shards_output",
        "type": "object",
        "properties": {
          "shard-result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result1"
            },
            "description": "The list of results, one per shard"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_shard-result1": {
        "title": "cluster-admin_shard-result",
        "type": "object",
        "description": "The list of results, one per shard",
        "properties": {
          "known-clients": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster-admin_shard-result_known-clients"
            },
            "description": ""
          },
          "error-message": {
            "description": "",
            "type": "string",
            "example": "Some error-message"
          },
          "data-store-type": {
            "description": "The type of the data store to which the shard belongs",
            "type": "string",
            "enum": [
              "config",
              "operational"
            ],
            "example": "config"
          },
          "succeeded": {
            "description": "",
            "type": "boolean",
            "example": true
          },
          "shard-name": {
            "description": "The name of the shard.",
            "type": "string",
            "example": "Some shard-name",
            "minLength": 1,
            "maxLength": 2147483647
          }
        },
        "required": [
          "data-store-type",
          "shard-name"
        ],
        "xml": {
          "name": "shard-result",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "cluster-admin_shard-result_known-clients": {
        "title": "cluster-admin_shard-result_known-clients",
        "type": "object",
        "properties": {
          "generation": {
            "description": "",
            "type": "integer",
            "example": 0
          },
          "member": {
            "description": "",
            "type": "string",
            "example": "Some member"
          },
          "type": {
            "description": "",
            "type": "string",
            "example": "",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "generation",
          "member",
          "type"
        ],
        "xml": {
          "name": "known-clients",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:cluster:admin"
        }
      },
      "distributed-datastore-provider_data-store-properties-container": {
        "title": "distributed-datastore-provider_data-store-properties-container",
        "type": "object",
        "properties": {
          "maximum-message-slice-size": {
            "description": "When fragmenting messages thru the akka remoting framework, this is the\nmaximum size in bytes for a message slice.",
            "type": "integer",
            "format": "int64",
            "default": 491520,
            "example": 1
          },
          "shard-snapshot-data-threshold": {
            "description": "The threshold of in-memory journal size before a snapshot is to be taken. If set to 0, direct threshold\nis disabled and percentage is used instead.",
            "type": "string",
            "default": "0"
          },
          "shard-leader-election-timeout-in-seconds": {
            "description": "The maximum amount of time to wait for a shard to elect a leader before failing\n an operation (eg transaction create).",
            "type": "integer",
            "format": "int64",
            "default": 30,
            "example": 1
          },
          "shard-heartbeat-interval-in-millis": {
            "description": "The interval at which a shard will send a heart beat message to its remote shard.",
            "type": "integer",
            "format": "int32",
            "default": 500,
            "example": 100
          },
          "shard-batched-modification-count": {
            "description": "The number of transaction modification operations (put, merge, delete) to\nbatch before sending to the shard transaction actor. Batching improves\nperformance as less modifications messages are sent to the actor and thus\nlessens the chance that the transaction actor's mailbox queue could get full.",
            "type": "integer",
            "format": "int64",
            "default": 1000,
            "example": 1
          },
          "transaction-debug-context-enabled": {
            "description": "Enable or disable transaction context debug. This will log the call site trace for\ntransactions that fail",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "custom-raft-policy-implementation": {
            "description": "A fully qualified java class name. The class should implement\norg.opendaylight.controller.cluster.raft.policy.RaftPolicy. This java class should be\naccessible to the distributed data store OSGi module so that it can be dynamically loaded via\nreflection. For now let's assume that these classes to customize raft behaviors should be\npresent in the distributed data store module itself. If this property is set to a class which\ncannot be found then the default raft behavior will be applied",
            "type": "string",
            "default": "",
            "example": "Some custom-raft-policy-implementation"
          },
          "shard-transaction-idle-timeout-in-minutes": {
            "description": "The maximum amount of time a shard transaction can be idle without receiving any messages before it self-destructs.",
            "type": "integer",
            "format": "int64",
            "default": 10,
            "example": 1
          },
          "shard-transaction-commit-timeout-in-seconds": {
            "description": "The maximum amount of time a shard transaction three-phase commit can be idle without receiving the next messages before it aborts the transaction",
            "type": "integer",
            "format": "int64",
            "default": 30,
            "example": 1
          },
          "recovery-export-base-dir": {
            "description": "Directory name for snapshot and journal dumps.",
            "type": "string",
            "default": "persistence-export",
            "example": "Some recovery-export-base-dir"
          },
          "snapshotOnRootOverwrite": {
            "description": "Enable or disable capturing snapshots on DataTree root overwrites",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "shard-commit-queue-expiry-timeout-in-seconds": {
            "description": "The maximum amount of time a transaction can remain in a shard's commit queue waiting\nto begin the CanCommit phase as coordinated by the broker front-end. Normally this should be\nquick but latencies can occur in between transaction ready and CanCommit or a remote broker\ncould lose connection and CanCommit might never occur. Expiring transactions from the queue\nallows subsequent pending transaction to be processed.",
            "type": "integer",
            "format": "int64",
            "default": 120,
            "example": 1
          },
          "frontend-no-progress-timeout-in-seconds": {
            "description": "The timeout interval whereby the client front-end hasn't made progress with the\nback-end on any request and terminates.",
            "type": "integer",
            "format": "int64",
            "default": 900,
            "example": 1
          },
          "shard-journal-recovery-log-batch-size": {
            "description": "The maximum number of journal log entries to batch on recovery for a shard before committing to the data store.",
            "type": "integer",
            "format": "int64",
            "default": 1,
            "example": 1
          },
          "shard-initialization-timeout-in-seconds": {
            "description": "The maximum amount of time to wait for a shard to initialize from persistence\non startup before failing an operation (eg transaction create and change\nlistener registration).",
            "type": "integer",
            "format": "int64",
            "default": 300,
            "example": 1
          },
          "frontend-request-timeout-in-seconds": {
            "description": "The timeout interval whereby client frontend transaction requests are failed.",
            "type": "integer",
            "format": "int64",
            "default": 120,
            "example": 1
          },
          "enable-metric-capture": {
            "description": "Enable or disable metric capture.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "shard-election-timeout-factor": {
            "description": "The multiplication factor to be used to determine shard election timeout. The shard election timeout\nis determined by multiplying shard-heartbeat-interval-in-millis with the shard-election-timeout-factor",
            "type": "integer",
            "format": "int64",
            "default": 20,
            "example": 1
          },
          "persistent": {
            "description": "Enable or disable data persistence",
            "type": "boolean",
            "default": true,
            "example": true
          },
          "recovery-snapshot-interval-seconds": {
            "description": "Interval after which a snapshot should be taken during the recovery process.",
            "type": "string",
            "default": "0"
          },
          "shard-snapshot-data-threshold-percentage": {
            "description": "The percentage of Runtime.maxMemory() used by the in-memory journal log before a snapshot is to be taken.\nDisabled, if direct threshold is enabled.",
            "type": "integer",
            "format": "int32",
            "default": 12,
            "example": 0
          },
          "operation-timeout-in-seconds": {
            "description": "The maximum amount of time for akka operations (remote or local) to complete before failing.",
            "type": "integer",
            "format": "int32",
            "default": 5,
            "example": 5
          },
          "shard-snapshot-batch-count": {
            "description": "The minimum number of entries to be present in the in-memory journal log before a snapshot is to be taken.",
            "type": "integer",
            "format": "int64",
            "default": 20000,
            "example": 1
          },
          "shard-transaction-commit-queue-capacity": {
            "description": "The maximum allowed capacity for each shard's transaction commit queue.",
            "type": "integer",
            "format": "int64",
            "default": 50000,
            "example": 1
          },
          "initial-payload-serialized-buffer-capacity": {
            "description": "The initial buffer capacity, in bytes, to use when serializing message payloads.",
            "type": "integer",
            "format": "int64",
            "default": 512,
            "example": 1
          },
          "bounded-mailbox-capacity": {
            "description": "Max queue size that an actor's mailbox can reach",
            "type": "integer",
            "format": "int64",
            "default": 1000,
            "example": 1
          },
          "sync-index-threshold": {
            "description": "Permitted synchronization lag, expressed in terms of RAFT entry count. It a follower's\ncommitIndex trails the leader's journal by more than this amount of entries the follower\nis considered to be out-of-sync.",
            "type": "integer",
            "format": "int64",
            "default": 10,
            "example": 1
          },
          "transaction-creation-initial-rate-limit": {
            "description": "The initial number of transactions per second that are allowed before the data store\nshould begin applying back pressure. This number is only used as an initial guidance,\nsubsequently the datastore measures the latency for a commit and auto-adjusts the rate limit",
            "type": "integer",
            "format": "int64",
            "default": 100,
            "example": 1
          },
          "file-backed-streaming-threshold-in-megabytes": {
            "description": "When streaming large amounts of data, eg when sending a snapshot to a follower, this\nis the threshold in terms of number of megabytes before it should switch from storing in memory to\nbuffering to a file.",
            "type": "integer",
            "format": "int64",
            "default": 128,
            "example": 1
          },
          "export-on-recovery": {
            "description": "Export snapshot and journal during recovery. Possible modes: off(default),\njson(export to json files). Note that in case of large snapshot,\nexport will take a lot of time.",
            "type": "string",
            "enum": [
              "off",
              "json"
            ],
            "default": "off",
            "example": "off"
          },
          "initial-settle-timeout-multiplier": {
            "description": "Multiplier for the maximum amount of time to wait for a shard to elect a leader.\nZero value means wait indefinitely (as long as it takes).",
            "type": "integer",
            "format": "int64",
            "default": 3,
            "example": 0
          },
          "shard-isolated-leader-check-interval-in-millis": {
            "description": "The interval at which the leader of the shard will check if its majority\nfollowers are active and term itself as isolated",
            "type": "integer",
            "format": "int32",
            "default": 5000,
            "example": 100
          },
          "use-lz4-compression": {
            "description": "Use lz4 compression for snapshots, sent from leader to follower, for snapshots stored\nby LocalSnapshotStore, use akka.conf configuration.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "backend-aliveness-timer-interval-in-seconds": {
            "description": "The timer interval whereby, on expiration after response inactivity from the back-end,\nthe connection to the back-end is torn down and reconnection is attempted.",
            "type": "integer",
            "format": "int64",
            "default": 30,
            "example": 1
          }
        },
        "xml": {
          "name": "data-store-properties-container",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:config:distributed-datastore-provider"
        }
      },
      "ietf-netconf_get-config_input": {
        "title": "ietf-netconf_get-config_input",
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ietf-netconf_source"
          },
          "filter": {
            "description": "Subtree or XPath filter to use.",
            "example": "<filter> ... </filter>",
            "type": "string"
          },
          "with-defaults": {
            "description": "The explicit defaults processing mode requested.",
            "type": "string",
            "enum": [
              "report-all",
              "report-all-tagged",
              "trim",
              "explicit"
            ],
            "example": "report-all",
            "xml": {
              "name": "with-defaults",
              "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults"
            }
          }
        },
        "required": [
          "source"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_source": {
        "title": "ietf-netconf_source",
        "type": "object",
        "description": "Particular configuration to retrieve.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config source.",
            "type": "object"
          }
        },
        "xml": {
          "name": "source",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_get-config_output": {
        "title": "ietf-netconf_get-config_output",
        "type": "object",
        "properties": {
          "data": {
            "description": "Copy of the source datastore subset that matched\nthe filter criteria (if any).  An empty data container\nindicates that the request did not produce any results.",
            "example": "<data> ... </data>",
            "type": "string"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_edit-config_input": {
        "title": "ietf-netconf_edit-config_input",
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/ietf-netconf_target"
          },
          "default-operation": {
            "description": "The default operation to use.",
            "type": "string",
            "enum": [
              "merge",
              "replace",
              "none"
            ],
            "default": "merge",
            "example": "merge"
          },
          "test-option": {
            "description": "The test option to use.",
            "type": "string",
            "enum": [
              "test-then-set",
              "set",
              "test-only"
            ],
            "default": "test-then-set",
            "example": "test-then-set"
          },
          "error-option": {
            "description": "The error option to use.",
            "type": "string",
            "enum": [
              "stop-on-error",
              "continue-on-error",
              "rollback-on-error"
            ],
            "default": "stop-on-error",
            "example": "stop-on-error"
          },
          "config": {
            "description": "Inline Config content.",
            "example": "<config> ... </config>",
            "type": "string"
          }
        },
        "required": [
          "target"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_target": {
        "title": "ietf-netconf_target",
        "type": "object",
        "description": "Particular configuration to edit.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config target.",
            "type": "object"
          }
        },
        "xml": {
          "name": "target",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_copy-config_input": {
        "title": "ietf-netconf_copy-config_input",
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/ietf-netconf_target1"
          },
          "source": {
            "$ref": "#/components/schemas/ietf-netconf_source1"
          },
          "with-defaults": {
            "description": "The explicit defaults processing mode requested.",
            "type": "string",
            "enum": [
              "report-all",
              "report-all-tagged",
              "trim",
              "explicit"
            ],
            "example": "report-all",
            "xml": {
              "name": "with-defaults",
              "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults"
            }
          }
        },
        "required": [
          "target",
          "source"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_target1": {
        "title": "ietf-netconf_target",
        "type": "object",
        "description": "Particular configuration to copy to.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config target.",
            "type": "object"
          }
        },
        "xml": {
          "name": "target",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_source1": {
        "title": "ietf-netconf_source",
        "type": "object",
        "description": "Particular configuration to copy from.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config source.",
            "type": "object"
          }
        },
        "xml": {
          "name": "source",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_delete-config_input": {
        "title": "ietf-netconf_delete-config_input",
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/ietf-netconf_target2"
          }
        },
        "required": [
          "target"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_target2": {
        "title": "ietf-netconf_target",
        "type": "object",
        "description": "Particular configuration to delete.",
        "properties": {
          "startup": {
            "description": "The startup configuration is the config target.",
            "type": "object"
          }
        },
        "xml": {
          "name": "target",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_lock_input": {
        "title": "ietf-netconf_lock_input",
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/ietf-netconf_target3"
          }
        },
        "required": [
          "target"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_target3": {
        "title": "ietf-netconf_target",
        "type": "object",
        "description": "Particular configuration to lock.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config target.",
            "type": "object"
          }
        },
        "xml": {
          "name": "target",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_unlock_input": {
        "title": "ietf-netconf_unlock_input",
        "type": "object",
        "properties": {
          "target": {
            "$ref": "#/components/schemas/ietf-netconf_target4"
          }
        },
        "required": [
          "target"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_target4": {
        "title": "ietf-netconf_target",
        "type": "object",
        "description": "Particular configuration to unlock.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config target.",
            "type": "object"
          }
        },
        "xml": {
          "name": "target",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_get_input": {
        "title": "ietf-netconf_get_input",
        "type": "object",
        "properties": {
          "filter": {
            "description": "This parameter specifies the portion of the system\nconfiguration and state data to retrieve.",
            "example": "<filter> ... </filter>",
            "type": "string"
          },
          "with-defaults": {
            "description": "The explicit defaults processing mode requested.",
            "type": "string",
            "enum": [
              "report-all",
              "report-all-tagged",
              "trim",
              "explicit"
            ],
            "example": "report-all",
            "xml": {
              "name": "with-defaults",
              "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults"
            }
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_get_output": {
        "title": "ietf-netconf_get_output",
        "type": "object",
        "properties": {
          "data": {
            "description": "Copy of the running datastore subset and/or state\ndata that matched the filter criteria (if any).\nAn empty data container indicates that the request did not\nproduce any results.",
            "example": "<data> ... </data>",
            "type": "string"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_kill-session_input": {
        "title": "ietf-netconf_kill-session_input",
        "type": "object",
        "properties": {
          "session-id": {
            "description": "Particular session to kill.",
            "type": "integer",
            "format": "int64",
            "example": 1
          }
        },
        "required": [
          "session-id"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_commit_input": {
        "title": "ietf-netconf_commit_input",
        "type": "object",
        "properties": {
          "confirmed": {
            "description": "Requests a confirmed commit.",
            "type": "object"
          },
          "confirm-timeout": {
            "description": "The timeout interval for a confirmed commit.",
            "type": "integer",
            "format": "int64",
            "default": 600,
            "example": 1
          },
          "persist": {
            "description": "This parameter is used to make a confirmed commit\npersistent.  A persistent confirmed commit is not aborted\nif the NETCONF session terminates.  The only way to abort\na persistent confirmed commit is to let the timer expire,\nor to use the <cancel-commit> operation.\n\nThe value of this parameter is a token that must be given\nin the 'persist-id' parameter of <commit> or\n<cancel-commit> operations in order to confirm or cancel\nthe persistent confirmed commit.\n\nThe token should be a random string.",
            "type": "string",
            "example": "Some persist"
          },
          "persist-id": {
            "description": "This parameter is given in order to commit a persistent\nconfirmed commit.  The value must be equal to the value\ngiven in the 'persist' parameter to the <commit> operation.\nIf it does not match, the operation fails with an\n'invalid-value' error.",
            "type": "string",
            "example": "Some persist-id"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_cancel-commit_input": {
        "title": "ietf-netconf_cancel-commit_input",
        "type": "object",
        "properties": {
          "persist-id": {
            "description": "This parameter is given in order to cancel a persistent\nconfirmed commit.  The value must be equal to the value\ngiven in the 'persist' parameter to the <commit> operation.\nIf it does not match, the operation fails with an\n'invalid-value' error.",
            "type": "string",
            "example": "Some persist-id"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_validate_input": {
        "title": "ietf-netconf_validate_input",
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ietf-netconf_source2"
          }
        },
        "required": [
          "source"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf_source2": {
        "title": "ietf-netconf_source",
        "type": "object",
        "description": "Particular configuration to validate.",
        "properties": {
          "candidate": {
            "description": "The candidate configuration is the config source.",
            "type": "object"
          }
        },
        "xml": {
          "name": "source",
          "namespace": "urn:ietf:params:xml:ns:netconf:base:1.0"
        }
      },
      "ietf-netconf-acm_nacm": {
        "title": "ietf-netconf-acm_nacm",
        "type": "object",
        "description": "Parameters for NETCONF access control model.",
        "properties": {
          "write-default": {
            "description": "Controls whether create, update, or delete access\nis granted if no appropriate rule is found for a\nparticular write request.",
            "type": "string",
            "enum": [
              "permit",
              "deny"
            ],
            "default": "deny",
            "example": "permit"
          },
          "read-default": {
            "description": "Controls whether read access is granted if\nno appropriate rule is found for a\nparticular read request.",
            "type": "string",
            "enum": [
              "permit",
              "deny"
            ],
            "default": "permit",
            "example": "permit"
          },
          "enable-nacm": {
            "description": "Enables or disables all NETCONF access control\nenforcement.  If 'true', then enforcement\nis enabled.  If 'false', then enforcement\nis disabled.",
            "type": "boolean",
            "default": true,
            "example": true
          },
          "rule-list": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list"
            },
            "description": "An ordered collection of access control rules."
          },
          "exec-default": {
            "description": "Controls whether exec access is granted if no appropriate\nrule is found for a particular protocol operation request.",
            "type": "string",
            "enum": [
              "permit",
              "deny"
            ],
            "default": "permit",
            "example": "permit"
          },
          "groups": {
            "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups"
          },
          "enable-external-groups": {
            "description": "Controls whether the server uses the groups reported by the\nNETCONF transport layer when it assigns the user to a set of\nNACM groups.  If this leaf has the value 'false', any group\nnames reported by the transport layer are ignored by the\nserver.",
            "type": "boolean",
            "default": true,
            "example": true
          }
        },
        "xml": {
          "name": "nacm",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm"
        }
      },
      "ietf-netconf-acm_nacm_groups": {
        "title": "ietf-netconf-acm_nacm_groups",
        "type": "object",
        "description": "NETCONF access control groups.",
        "properties": {
          "group": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-acm_nacm_groups_group"
            },
            "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols."
          }
        },
        "xml": {
          "name": "groups",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm"
        }
      },
      "ietf-netconf-acm_nacm_groups_group": {
        "title": "ietf-netconf-acm_nacm_groups_group",
        "type": "object",
        "description": "One NACM group entry.  This list will only contain\nconfigured entries, not any entries learned from\nany transport protocols.",
        "properties": {
          "user-name": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some user-name",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "Each entry identifies the username of\na member of the group associated with\nthis entry."
          },
          "name": {
            "description": "Group name associated with this entry.",
            "type": "string",
            "example": "\u0000",
            "minLength": 1,
            "maxLength": 2147483647
          }
        },
        "xml": {
          "name": "group",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm"
        }
      },
      "ietf-netconf-acm_nacm_rule-list": {
        "title": "ietf-netconf-acm_nacm_rule-list",
        "type": "object",
        "description": "An ordered collection of access control rules.",
        "properties": {
          "name": {
            "description": "Arbitrary name assigned to the rule-list.",
            "type": "string",
            "example": "Some name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "rule": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-acm_nacm_rule-list_rule"
            },
            "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted."
          },
          "group": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "*",
              "minLength": 0,
              "maxLength": 2147483647
            },
            "description": "List of administrative groups that will be\nassigned the associated access rights\ndefined by the 'rule' list.\n\nThe string '*' indicates that all groups apply to the\nentry."
          }
        },
        "xml": {
          "name": "rule-list",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm"
        }
      },
      "ietf-netconf-acm_nacm_rule-list_rule": {
        "title": "ietf-netconf-acm_nacm_rule-list_rule",
        "type": "object",
        "description": "One access control rule.\n\nRules are processed in user-defined order until a match is\nfound.  A rule matches if 'module-name', 'rule-type', and\n'access-operations' match the request.  If a rule\nmatches, the 'action' leaf determines whether or not\naccess is granted.",
        "properties": {
          "rpc-name": {
            "description": "This leaf matches if it has the value '*' or if\nits value equals the requested protocol operation\nname.",
            "type": "string",
            "example": "*",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "name": {
            "description": "Arbitrary name assigned to the rule.",
            "type": "string",
            "example": "Some name",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "access-operations": {
            "description": "Access operations associated with this rule.\n\nThis leaf matches if it has the value '*' or if the\nbit corresponding to the requested operation is set.",
            "type": "string",
            "default": "*",
            "example": "*",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "module-name": {
            "description": "Name of the module associated with this rule.\n\nThis leaf matches if it has the value '*' or if the\nobject being accessed is defined in the module with the\nspecified module name.",
            "type": "string",
            "default": "*",
            "example": "*",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "action": {
            "description": "The access control action associated with the\nrule.  If a rule has been determined to match a\nparticular request, then this object is used\nto determine whether to permit or deny the\nrequest.",
            "type": "string",
            "enum": [
              "permit",
              "deny"
            ],
            "example": "permit"
          },
          "comment": {
            "description": "A textual description of the access rule.",
            "type": "string",
            "example": "Some comment"
          }
        },
        "required": [
          "action"
        ],
        "xml": {
          "name": "rule",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-acm"
        }
      },
      "ietf-netconf-client_netconf-client": {
        "title": "ietf-netconf-client_netconf-client",
        "type": "object",
        "description": "Top-level container for NETCONF client configuration.",
        "properties": {
          "initiate": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate"
          },
          "listen": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen"
          }
        },
        "xml": {
          "name": "netconf-client",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate": {
        "title": "ietf-netconf-client_netconf-client_initiate",
        "type": "object",
        "description": "Configures client initiating underlying TCP connections.",
        "properties": {
          "netconf-server": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server"
            },
            "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "netconf-server"
        ],
        "xml": {
          "name": "initiate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server",
        "type": "object",
        "description": "List of NETCONF servers the NETCONF client is to\nmaintain simultaneous connections with.",
        "properties": {
          "endpoints": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints"
          },
          "connection-type": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type"
          },
          "name": {
            "description": "An arbitrary name for the NETCONF server.",
            "type": "string",
            "example": "Some name"
          },
          "reconnect-strategy": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy"
          }
        },
        "required": [
          "connection-type"
        ],
        "xml": {
          "name": "netconf-server",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints",
        "type": "object",
        "description": "Container for the list of endpoints.",
        "properties": {
          "endpoint": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint"
            },
            "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "endpoint"
        ],
        "xml": {
          "name": "endpoints",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint",
        "type": "object",
        "description": "A user-ordered list of endpoints that the NETCONF\nclient will attempt to connect to in the specified\nsequence.  Defining more than one enables\nhigh-availability.",
        "properties": {
          "name": {
            "description": "An arbitrary name for the endpoint.",
            "type": "string",
            "example": "Some name"
          },
          "ssh": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh"
          }
        },
        "xml": {
          "name": "endpoint",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh",
        "type": "object",
        "description": "Specifies TCP, SSH, and NETCONF configuration\nfor the connection.",
        "properties": {
          "ssh-client-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters"
          },
          "netconf-client-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_netconf-client-parameters"
          },
          "tcp-client-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters"
          }
        },
        "required": [
          "tcp-client-parameters"
        ],
        "xml": {
          "name": "ssh",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters",
        "type": "object",
        "description": "TCP-level client parameters to initiate\na NETCONF over SSH connection.",
        "properties": {
          "local-port": {
            "description": "The local IP port number to bind to for when connecting\nto the remote peer.  The port number '0', which is the\ndefault value, indicates that any available local port\nnumber may be used.",
            "type": "string",
            "default": "0"
          },
          "keepalives": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters_keepalives"
          },
          "remote-address": {
            "description": "The IP address or hostname of the remote peer to\nestablish a connection with.  If a domain name is\nconfigured, then the DNS resolution should happen on\neach connection attempt.  If the DNS resolution\nresults in multiple IP addresses, the IP addresses\nare tried according to local preference order until\na connection has been established or until all IP\naddresses have failed.",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "remote-port": {
            "description": "The NETCONF client will attempt to connect\nto the IANA-assigned well-known port value\nfor 'netconf-ssh' (830) if no value is\nspecified.",
            "type": "integer",
            "format": "int32",
            "default": 830,
            "example": 0
          },
          "local-address": {
            "description": "The local IP address/interface to bind to for when\nconnecting to the remote peer.  INADDR_ANY ('0.0.0.0') or\nINADDR6_ANY ('0:0:0:0:0:0:0:0' a.k.a. '::') MAY be used to\nexplicitly indicate the implicit default, that the server\ncan bind to any IPv4 or IPv6 addresses, respectively.",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "remote-address"
        ],
        "xml": {
          "name": "tcp-client-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters_keepalives": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_tcp-client-parameters_keepalives",
        "type": "object",
        "description": "An if-feature statement so that implementations\ncan choose to support TCP client keepalives.",
        "properties": {
          "idle-time": {
            "description": "Sets the amount of time after which if no data has been\nreceived from the TCP peer, a TCP-level probe message\nwill be sent to test the aliveness of the TCP peer.\nTwo hours (7200 seconds) is safe value, per RFC 9293\nSection 3.8.4.",
            "type": "integer",
            "format": "int32",
            "default": 7200,
            "example": 1
          },
          "probe-interval": {
            "description": "Sets the time interval between failed probes. The interval\nSHOULD be significantly longer than one second in order to\navoid harm on a congested link.",
            "type": "integer",
            "format": "int32",
            "default": 75,
            "example": 1
          },
          "max-probes": {
            "description": "Sets the maximum number of sequential keep-alive probes\nthat can fail to obtain a response from the TCP peer\nbefore assuming the TCP peer is no longer alive.",
            "type": "integer",
            "format": "int32",
            "default": 9,
            "example": 1
          }
        },
        "xml": {
          "name": "keepalives",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters",
        "type": "object",
        "description": "SSH-level client parameters to initiate\na NETCONF over SSH connection.",
        "properties": {
          "server-authentication": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication"
          },
          "transport-params": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params"
          },
          "keepalives": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_keepalives"
          },
          "client-identity": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity"
          }
        },
        "xml": {
          "name": "ssh-client-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity",
        "type": "object",
        "description": "The username and authentication methods for the client.\nThe authentication methods are unordered.  Clients may\ninitially send any configured method or, per RFC 4252,\nSection 5.2, send the 'none' method to prompt the server\nto provide a list of productive methods.  Whenever a\nchoice amongst methods arises, implementations SHOULD\nuse a default ordering that prioritizes automation\nover human-interaction.",
        "properties": {
          "password": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password"
          },
          "certificate": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate"
          },
          "public-key": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key"
          },
          "hostbased": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased"
          },
          "username": {
            "description": "The username of this user.  This will be the username\nused, for instance, to log into an SSH server.",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "client-identity",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key",
        "type": "object",
        "description": "A locally-defined or referenced asymmetric key\npair to be used for client identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "public-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password",
        "type": "object",
        "description": "A password to be used to authenticate the client's\nidentity.",
        "properties": {
          "cleartext-password": {
            "description": "The cleartext value of the password.",
            "type": "string",
            "example": "Some cleartext-password"
          }
        },
        "xml": {
          "name": "password",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased",
        "type": "object",
        "description": "A locally-defined or referenced asymmetric key\npair to be used for host identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "hostbased",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate",
        "type": "object",
        "description": "A locally-defined or referenced certificate\nto be used for client identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_input": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_input",
        "type": "object",
        "properties": {
          "csr-format": {
            "description": "Specifies the format for the returned certificate.",
            "type": "string",
            "enum": [
              "csr-format",
              "p10-csr-format"
            ],
            "example": "csr-format"
          },
          "csr-info": {
            "description": "A CertificationRequestInfo structure, as defined in\nRFC 2986.\n\nEnables the client to provide a fully-populated\nCertificationRequestInfo structure that the server\nonly needs to sign in order to generate the complete\n'CertificationRequest' structure to return in the\n'output'.\n\nThe 'AlgorithmIdentifier' field contained inside\nthe 'SubjectPublicKeyInfo' field MUST be one known\nto be supported by the device.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "csr-format",
          "csr-info"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_output": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_output",
        "type": "object",
        "properties": {
          "p10-csr": {
            "description": "A CertificationRequest, as defined in RFC 2986.",
            "type": "string",
            "format": "byte"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication",
        "type": "object",
        "description": "Specifies how the SSH client can authenticate SSH servers.\nAny combination of authentication methods is additive and\nunordered.",
        "properties": {
          "ssh-host-keys": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys"
          },
          "ee-certs": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs"
          },
          "ca-certs": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs"
          }
        },
        "xml": {
          "name": "server-authentication",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys",
        "type": "object",
        "description": "A bag of SSH host keys used by the SSH client to\nauthenticate SSH server host keys.  A server host key\nis authenticated if it is an exact match to a\nconfigured SSH host key.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition"
          }
        },
        "xml": {
          "name": "ssh-host-keys",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition",
        "type": "object",
        "description": "A container to hold local public key definitions.",
        "properties": {
          "public-key": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key"
            },
            "description": "A public key definition."
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key",
        "type": "object",
        "description": "A public key definition.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this public key.",
            "type": "string",
            "example": "Some name"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "required": [
          "public-key",
          "public-key-format"
        ],
        "xml": {
          "name": "public-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs",
        "type": "object",
        "description": "A set of certificate authority (CA) certificates used by\nthe SSH client to authenticate SSH servers.  A server\nis authenticated if its certificate has a valid chain\nof trust to a configured CA certificate.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition"
          }
        },
        "xml": {
          "name": "ca-certs",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition",
        "type": "object",
        "description": "A container for locally configured trust anchor\ncertificates.",
        "properties": {
          "certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate"
            },
            "description": "A trust anchor certificate or chain of certificates.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "certificate"
        ],
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate",
        "type": "object",
        "description": "A trust anchor certificate or chain of certificates.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this certificate.",
            "type": "string",
            "example": "Some name"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "cert-data"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs",
        "type": "object",
        "description": "A set of end-entity certificates used by the SSH client\nto authenticate SSH servers.  A server is authenticated\nif its certificate is an exact match to a configured\nend-entity certificate.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition"
          }
        },
        "xml": {
          "name": "ee-certs",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition",
        "type": "object",
        "description": "A container for locally configured trust anchor\ncertificates.",
        "properties": {
          "certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate"
            },
            "description": "A trust anchor certificate or chain of certificates.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "certificate"
        ],
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate",
        "type": "object",
        "description": "A trust anchor certificate or chain of certificates.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this certificate.",
            "type": "string",
            "example": "Some name"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "cert-data"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params",
        "type": "object",
        "description": "Configurable parameters of the SSH transport layer.",
        "properties": {
          "key-exchange": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange"
          },
          "encryption": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption"
          },
          "host-key": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key"
          },
          "mac": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac"
          }
        },
        "xml": {
          "name": "transport-params",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key",
        "type": "object",
        "description": "Parameters regarding host key.",
        "properties": {
          "host-key-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "public-key-alg-base",
                "x509v3-ecdsa-sha2-1.3.132.0.33",
                "x509v3-ecdsa-sha2-nistp521",
                "x509v3-ecdsa-sha2-1.3.132.0.26",
                "x509v3-ecdsa-sha2-1.3.132.0.38",
                "x509v3-ssh-rsa",
                "spki-sign-dss",
                "ecdsa-sha2-nistp521",
                "ssh-ed448",
                "pgp-sign-rsa",
                "ssh-rsa",
                "rsa-sha2-256",
                "ecdsa-sha2-1.3.132.0.33",
                "x509v3-ecdsa-sha2-1.3.132.0.1",
                "x509v3-ecdsa-sha2-1.3.132.0.27",
                "ecdsa-sha2-1.2.840.10045.3.1.1",
                "x509v3-ecdsa-sha2-1.3.132.0.36",
                "ecdsa-sha2-1.3.132.0.37",
                "x509v3-ecdsa-sha2-nistp384",
                "ecdsa-sha2-1.3.132.0.26",
                "ecdsa-sha2-1.3.132.0.27",
                "x509v3-ecdsa-sha2-nistp256",
                "x509v3-ssh-dss",
                "ssh-ed25519",
                "x509v3-ecdsa-sha2-1.3.132.0.37",
                "ecdsa-sha2-nistp256",
                "pgp-sign-dss",
                "ssh-dss",
                "ecdsa-sha2-1.3.132.0.38",
                "ecdsa-sha2-1.3.132.0.1",
                "rsa-sha2-512",
                "ecdsa-sha2-nistp384",
                "x509v3-ecdsa-sha2-1.3.132.0.16",
                "null",
                "x509v3-rsa2048-sha256",
                "spki-sign-rsa",
                "ecdsa-sha2-1.3.132.0.36",
                "ecdsa-sha2-1.3.132.0.16",
                "x509v3-ecdsa-sha2-1.2.840.10045.3.1.1"
              ],
              "example": "public-key-alg-base"
            },
            "description": "Acceptable host key algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable host key algorithms are implementation-\ndefined."
          }
        },
        "xml": {
          "name": "host-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange",
        "type": "object",
        "description": "Parameters regarding key exchange.",
        "properties": {
          "key-exchange-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "key-exchange-alg-base",
                "ecdh-sha2-1.3.132.0.38",
                "gss-group1-sha1-1.3.132.0.33",
                "gss-group18-sha512-1.3.132.0.26",
                "gss-group18-sha512-1.3.132.0.33",
                "ecdh-sha2-nistp256",
                "ecdh-sha2-1.2.840.10045.3.1.1",
                "gss-nistp521-sha512-1.3.132.0.37",
                "gss-group17-sha512-nistp521",
                "gss-group14-sha1-1.3.132.0.16",
                "gss-nistp384-sha384-nistp384",
                "gss-curve448-sha512-1.3.132.0.27",
                "gss-group17-sha512-1.3.132.0.38",
                "gss-nistp384-sha384-1.3.132.0.37",
                "gss-group14-sha256-nistp521",
                "gss-group17-sha512-1.3.132.0.16",
                "gss-group1-sha1-1.3.132.0.36",
                "gss-nistp256-sha256-nistp521",
                "ecdh-sha2-nistp521",
                "gss-gex-sha1-1.3.132.0.16",
                "gss-gex-sha1-1.3.132.0.33",
                "gss-group14-sha1-1.3.132.0.33",
                "ecmqv-sha2",
                "gss-group1-sha1-1.3.132.0.38",
                "rsa1024-sha1",
                "gss-group16-sha512-1.3.132.0.1",
                "gss-group1-sha1-1.3.132.0.37",
                "gss-group17-sha512-1.3.132.0.37",
                "gss-group18-sha512-nistp521",
                "diffie-hellman-group15-sha512",
                "gss-nistp384-sha384-1.3.132.0.36",
                "gss-nistp256-sha256-nistp256",
                "gss-curve25519-sha256-nistp521",
                "ecdh-sha2-1.3.132.0.26",
                "gss-group14-sha1-nistp256",
                "gss-group14-sha256-1.3.132.0.27",
                "ext-info-c",
                "gss-group14-sha1-1.3.132.0.1",
                "gss-curve448-sha512-nistp384",
                "gss-group14-sha1-nistp384",
                "gss-group15-sha512-nistp256",
                "gss-group17-sha512-nistp256",
                "gss-curve448-sha512-1.2.840.10045.3.1.1",
                "gss-group15-sha512-1.3.132.0.27",
                "gss-gex-sha1-1.3.132.0.37",
                "gss-group14-sha256-1.3.132.0.38",
                "gss-group15-sha512-1.3.132.0.33",
                "diffie-hellman-group16-sha512",
                "gss-nistp384-sha384-1.3.132.0.26",
                "gss-group15-sha512-1.3.132.0.38",
                "gss-group14-sha256-1.3.132.0.16",
                "diffie-hellman-group18-sha512",
                "gss-group14-sha256-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.3.132.0.27",
                "gss-group15-sha512-nistp521",
                "gss-group15-sha512-1.3.132.0.36",
                "gss-group17-sha512-1.3.132.0.36",
                "gss-nistp384-sha384-nistp256",
                "gss-nistp521-sha512-1.3.132.0.26",
                "gss-nistp256-sha256-1.3.132.0.36",
                "gss-curve448-sha512-1.3.132.0.1",
                "ecdh-sha2-1.3.132.0.36",
                "curve448-sha512",
                "gss-nistp521-sha512-1.3.132.0.16",
                "gss-group14-sha256-1.3.132.0.1",
                "gss-group18-sha512-1.3.132.0.1",
                "gss-nistp521-sha512-1.3.132.0.1",
                "gss-curve448-sha512-nistp521",
                "gss-nistp256-sha256-1.3.132.0.16",
                "gss-curve25519-sha256-1.3.132.0.16",
                "gss-curve25519-sha256-1.3.132.0.38",
                "ecdh-sha2-1.3.132.0.33",
                "gss-gex-sha1-1.3.132.0.36",
                "gss-group16-sha512-1.3.132.0.16",
                "gss-group17-sha512-1.3.132.0.26",
                "diffie-hellman-group14-sha256",
                "diffie-hellman-group14-sha1",
                "ecdh-sha2-1.3.132.0.16",
                "gss-group14-sha1-1.3.132.0.37",
                "gss-curve448-sha512-1.3.132.0.33",
                "gss-curve25519-sha256-1.2.840.10045.3.1.1",
                "gss-nistp256-sha256-1.3.132.0.38",
                "gss-nistp256-sha256-1.2.840.10045.3.1.1",
                "gss-group18-sha512-1.3.132.0.38",
                "ecdh-sha2-1.3.132.0.1",
                "gss-group14-sha256-1.3.132.0.33",
                "gss-group17-sha512-1.3.132.0.1",
                "gss-group18-sha512-1.3.132.0.16",
                "gss-group18-sha512-1.3.132.0.37",
                "gss-nistp521-sha512-1.3.132.0.27",
                "gss-nistp384-sha384-1.3.132.0.1",
                "gss-group16-sha512-nistp384",
                "gss-group15-sha512-nistp384",
                "diffie-hellman-group-exchange-sha1",
                "rsa2048-sha256",
                "gss-group15-sha512-1.3.132.0.26",
                "gss-curve25519-sha256-1.3.132.0.37",
                "diffie-hellman-group1-sha1",
                "gss-gex-sha1-1.3.132.0.26",
                "gss-gex-sha1-1.3.132.0.27",
                "gss-group16-sha512-nistp256",
                "gss-gex-sha1-nistp256",
                "gss-group16-sha512-1.3.132.0.36",
                "curve25519-sha256",
                "gss-group15-sha512-1.3.132.0.16",
                "gss-group1-sha1-1.3.132.0.1",
                "gss-group16-sha512-1.3.132.0.37",
                "gss-nistp256-sha256-1.3.132.0.37",
                "gss-group14-sha1-1.3.132.0.36",
                "gss-gex-sha1-nistp521",
                "gss-nistp384-sha384-1.3.132.0.16",
                "gss-nistp521-sha512-nistp256",
                "gss-curve25519-sha256-1.3.132.0.33",
                "gss-curve25519-sha256-1.3.132.0.1",
                "gss-curve448-sha512-nistp256",
                "gss-nistp256-sha256-1.3.132.0.26",
                "gss-nistp521-sha512-1.3.132.0.36",
                "ext-info-s",
                "gss-curve25519-sha256-nistp384",
                "gss-group18-sha512-nistp384",
                "gss-gex-sha1-1.2.840.10045.3.1.1",
                "gss-gex-sha1-1.3.132.0.1",
                "gss-gex-sha1-1.3.132.0.38",
                "gss-group17-sha512-nistp384",
                "gss-group1-sha1-nistp384",
                "gss-curve448-sha512-1.3.132.0.16",
                "gss-curve448-sha512-1.3.132.0.26",
                "gss-group16-sha512-nistp521",
                "gss-group16-sha512-1.3.132.0.38",
                "gss-group1-sha1-1.3.132.0.26",
                "gss-nistp384-sha384-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.3.132.0.16",
                "gss-group14-sha256-1.3.132.0.36",
                "gss-curve448-sha512-1.3.132.0.37",
                "gss-group14-sha256-1.3.132.0.26",
                "gss-group18-sha512-1.3.132.0.36",
                "ecdh-sha2-nistp384",
                "gss-nistp384-sha384-1.3.132.0.38",
                "gss-",
                "gss-group16-sha512-1.3.132.0.26",
                "gss-group14-sha256-nistp384",
                "gss-curve25519-sha256-1.3.132.0.27",
                "gss-group16-sha512-1.3.132.0.27",
                "gss-group18-sha512-nistp256",
                "gss-nistp384-sha384-1.3.132.0.27",
                "gss-group14-sha256-1.3.132.0.37",
                "gss-group14-sha1-1.2.840.10045.3.1.1",
                "gss-nistp384-sha384-1.3.132.0.33",
                "gss-curve448-sha512-1.3.132.0.38",
                "diffie-hellman-group17-sha512",
                "ecdh-sha2-1.3.132.0.37",
                "gss-nistp256-sha256-1.3.132.0.27",
                "gss-group16-sha512-1.2.840.10045.3.1.1",
                "gss-group16-sha512-1.3.132.0.33",
                "gss-nistp521-sha512-1.3.132.0.38",
                "gss-curve25519-sha256-nistp256",
                "gss-nistp384-sha384-nistp521",
                "gss-nistp256-sha256-1.3.132.0.1",
                "gss-nistp521-sha512-1.2.840.10045.3.1.1",
                "gss-group18-sha512-1.3.132.0.27",
                "gss-curve25519-sha256-1.3.132.0.26",
                "diffie-hellman-group-exchange-sha256",
                "gss-nistp521-sha512-nistp384",
                "gss-group1-sha1-nistp521",
                "gss-gex-sha1-nistp384",
                "gss-group17-sha512-1.2.840.10045.3.1.1",
                "gss-curve25519-sha256-1.3.132.0.36",
                "gss-group14-sha1-1.3.132.0.26",
                "ecdh-sha2-1.3.132.0.27",
                "gss-group17-sha512-1.3.132.0.33",
                "gss-group14-sha256-nistp256",
                "gss-nistp521-sha512-nistp521",
                "gss-group14-sha1-nistp521",
                "gss-curve448-sha512-1.3.132.0.36",
                "gss-group15-sha512-1.3.132.0.1",
                "gss-nistp256-sha256-nistp384",
                "gss-group14-sha1-1.3.132.0.38",
                "gss-group17-sha512-1.3.132.0.27",
                "gss-nistp256-sha256-1.3.132.0.33",
                "gss-nistp521-sha512-1.3.132.0.33",
                "gss-group15-sha512-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.2.840.10045.3.1.1",
                "gss-group1-sha1-nistp256",
                "gss-group14-sha1-1.3.132.0.27",
                "gss-group18-sha512-1.2.840.10045.3.1.1",
                "gss-group15-sha512-1.3.132.0.37"
              ],
              "example": "key-exchange-alg-base"
            },
            "description": "Acceptable key exchange algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable key exchange algorithms are implementation\ndefined."
          }
        },
        "xml": {
          "name": "key-exchange",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption",
        "type": "object",
        "description": "Parameters regarding encryption.",
        "properties": {
          "encryption-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "encryption-alg-base",
                "arcfour256",
                "aes256-cbc",
                "aes128-ctr",
                "twofish128-ctr",
                "serpent128-ctr",
                "aes128-cbc",
                "cast128-cbc",
                "serpent256-ctr",
                "twofish-cbc",
                "aes192-ctr",
                "serpent192-cbc",
                "none",
                "triple-des-cbc",
                "twofish192-cbc",
                "des-cbc",
                "AEAD_AES_128_GCM",
                "aes192-cbc",
                "blowfish-ctr",
                "blowfish-cbc",
                "twofish192-ctr",
                "twofish256-ctr",
                "twofish128-cbc",
                "idea-cbc",
                "serpent192-ctr",
                "cast128-ctr",
                "AEAD_AES_256_GCM",
                "idea-ctr",
                "arcfour",
                "serpent128-cbc",
                "aes256-ctr",
                "twofish256-cbc",
                "serpent256-cbc",
                "triple-des-ctr",
                "arcfour128"
              ],
              "example": "encryption-alg-base"
            },
            "description": "Acceptable encryption algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable encryption algorithms are implementation\ndefined."
          }
        },
        "xml": {
          "name": "encryption",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac",
        "type": "object",
        "description": "Parameters regarding message authentication code (MAC).",
        "properties": {
          "mac-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "mac-alg-base",
                "hmac-sha1-96",
                "AEAD_AES_256_GCM",
                "hmac-md5-96",
                "AEAD_AES_128_GCM",
                "hmac-sha1",
                "hmac-sha2-256",
                "hmac-md5",
                "none",
                "hmac-sha2-512"
              ],
              "example": "mac-alg-base"
            },
            "description": "Acceptable MAC algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable MAC algorithms are implementation-\ndefined."
          }
        },
        "xml": {
          "name": "mac",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_keepalives": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_ssh-client-parameters_keepalives",
        "type": "object",
        "description": "Configures the keep-alive policy, to proactively test\nthe aliveness of the SSH server.  An unresponsive SSH\nserver is dropped after approximately max-wait *\nmax-attempts seconds.  Per Section 4 of RFC 4254,\nthe SSH client SHOULD send an SSH_MSG_GLOBAL_REQUEST\nmessage with a purposely nonexistent 'request name'\nvalue (e.g., keepalive@ietf.org) and the 'want reply'\nvalue set to '1'.",
        "properties": {
          "max-attempts": {
            "description": "Sets the maximum number of sequential keep-alive\nmessages that can fail to obtain a response from\nthe SSH server before assuming the SSH server is\nno longer alive.",
            "type": "integer",
            "format": "int32",
            "default": 3,
            "example": 0
          },
          "max-wait": {
            "description": "Sets the amount of time in seconds after which if\nno data has been received from the SSH server, a\nSSH-level message will be sent to test the\naliveness of the SSH server.",
            "type": "integer",
            "format": "int32",
            "default": 30,
            "example": 1
          }
        },
        "xml": {
          "name": "keepalives",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_netconf-client-parameters": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_endpoints_endpoint_ssh_netconf-client-parameters",
        "type": "object",
        "description": "NETCONF-level client parameters to initiate\na NETCONF over SSH connection.",
        "properties": {},
        "xml": {
          "name": "netconf-client-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type",
        "type": "object",
        "description": "Indicates the NETCONF client's preference for how the\nNETCONF connection is maintained.",
        "properties": {
          "persistent": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type_persistent"
          }
        },
        "xml": {
          "name": "connection-type",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type_persistent": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_connection-type_persistent",
        "type": "object",
        "description": "Maintain a persistent connection to the NETCONF\nserver.  If the connection goes down, immediately\nstart trying to reconnect to the NETCONF server,\nusing the reconnection strategy.\n\nThis connection type minimizes any NETCONF server\nto NETCONF client data-transfer delay, albeit at\nthe expense of holding resources longer.",
        "properties": {},
        "xml": {
          "name": "persistent",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy": {
        "title": "ietf-netconf-client_netconf-client_initiate_netconf-server_reconnect-strategy",
        "type": "object",
        "description": "The reconnection strategy directs how a NETCONF client\nreconnects to a NETCONF server, after discovering its\nconnection to the server has dropped, even if due to a\nreboot.  The NETCONF client starts with the specified\nendpoint and tries to connect to it max-attempts times\nbefore trying the next endpoint in the list (round\nrobin).",
        "properties": {
          "max-attempts": {
            "description": "Specifies the number times the NETCONF client tries\nto connect to a specific endpoint before moving on\nto the next endpoint in the list (round robin).",
            "type": "integer",
            "format": "int32",
            "default": 3,
            "example": 1
          },
          "start-with": {
            "description": "Specifies which of the NETCONF server's endpoints\nthe NETCONF client should start with when trying\nto connect to the NETCONF server.",
            "type": "string",
            "enum": [
              "first-listed",
              "last-connected",
              "random-selection"
            ],
            "default": "first-listed",
            "example": "first-listed"
          },
          "max-wait": {
            "description": "Specifies the amount of time in seconds after which,\nif the connection is not established, an endpoint\nconnection attempt is considered unsuccessful.",
            "type": "integer",
            "format": "int32",
            "default": 5,
            "example": 1
          }
        },
        "xml": {
          "name": "reconnect-strategy",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen": {
        "title": "ietf-netconf-client_netconf-client_listen",
        "type": "object",
        "description": "Configures the client to accept call-home TCP connections.",
        "properties": {
          "endpoints": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints"
          },
          "idle-timeout": {
            "description": "Specifies the maximum number of seconds that a NETCONF\nsession may remain idle. A NETCONF session will be\ndropped if it is idle for an interval longer than this\nnumber of seconds.  If set to zero, then the server\nwill never drop a session because it is idle.",
            "type": "integer",
            "format": "int32",
            "default": 180,
            "example": 0
          }
        },
        "xml": {
          "name": "listen",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints",
        "type": "object",
        "description": "Container for a list of endpoints.",
        "properties": {
          "endpoint": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint"
            },
            "description": "List of endpoints to listen for NETCONF connections.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "endpoint"
        ],
        "xml": {
          "name": "endpoints",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint",
        "type": "object",
        "description": "List of endpoints to listen for NETCONF connections.",
        "properties": {
          "name": {
            "description": "An arbitrary name for the NETCONF listen endpoint.",
            "type": "string",
            "example": "Some name"
          },
          "ssh": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh"
          }
        },
        "xml": {
          "name": "endpoint",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh",
        "type": "object",
        "description": "TCP, SSH, and NETCONF configuration to listen\nfor NETCONF over SSH Call Home connections.",
        "properties": {
          "tcp-server-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters"
          },
          "ssh-client-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters"
          },
          "netconf-client-parameters": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_netconf-client-parameters"
          }
        },
        "required": [
          "tcp-server-parameters"
        ],
        "xml": {
          "name": "ssh",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters",
        "type": "object",
        "description": "TCP-level server parameters to listen for\nNETCONF over SSH Call Home connections.",
        "properties": {
          "local-port": {
            "description": "The NETCONF client will listen on the IANA-\nassigned well-known port for 'netconf-ch-ssh'\n(4334) if no value is specified.",
            "type": "integer",
            "format": "int32",
            "default": 4334,
            "example": 0
          },
          "keepalives": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters_keepalives"
          },
          "local-address": {
            "description": "The local IP address to listen on for incoming\nTCP client connections.  INADDR_ANY (0.0.0.0) or\nINADDR6_ANY (0:0:0:0:0:0:0:0 a.k.a. ::) MUST be\nused when the server is to listen on all IPv4 or\nIPv6 addresses, respectively.",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "local-address"
        ],
        "xml": {
          "name": "tcp-server-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters_keepalives": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_tcp-server-parameters_keepalives",
        "type": "object",
        "description": "An if-feature statement so that implementations\ncan choose to support TCP server keepalives.",
        "properties": {
          "idle-time": {
            "description": "Sets the amount of time after which if no data has been\nreceived from the TCP peer, a TCP-level probe message\nwill be sent to test the aliveness of the TCP peer.\nTwo hours (7200 seconds) is safe value, per RFC 9293\nSection 3.8.4.",
            "type": "integer",
            "format": "int32",
            "default": 7200,
            "example": 1
          },
          "probe-interval": {
            "description": "Sets the time interval between failed probes. The interval\nSHOULD be significantly longer than one second in order to\navoid harm on a congested link.",
            "type": "integer",
            "format": "int32",
            "default": 75,
            "example": 1
          },
          "max-probes": {
            "description": "Sets the maximum number of sequential keep-alive probes\nthat can fail to obtain a response from the TCP peer\nbefore assuming the TCP peer is no longer alive.",
            "type": "integer",
            "format": "int32",
            "default": 9,
            "example": 1
          }
        },
        "xml": {
          "name": "keepalives",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters",
        "type": "object",
        "description": "SSH-level client parameters to listen for\nNETCONF over SSH Call Home connections.",
        "properties": {
          "server-authentication": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication"
          },
          "transport-params": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params"
          },
          "keepalives": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_keepalives"
          },
          "client-identity": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity"
          }
        },
        "xml": {
          "name": "ssh-client-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity",
        "type": "object",
        "description": "The username and authentication methods for the client.\nThe authentication methods are unordered.  Clients may\ninitially send any configured method or, per RFC 4252,\nSection 5.2, send the 'none' method to prompt the server\nto provide a list of productive methods.  Whenever a\nchoice amongst methods arises, implementations SHOULD\nuse a default ordering that prioritizes automation\nover human-interaction.",
        "properties": {
          "password": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password"
          },
          "certificate": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate"
          },
          "public-key": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key"
          },
          "hostbased": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased"
          },
          "username": {
            "description": "The username of this user.  This will be the username\nused, for instance, to log into an SSH server.",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "client-identity",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key",
        "type": "object",
        "description": "A locally-defined or referenced asymmetric key\npair to be used for client identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "public-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_public-key_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_password",
        "type": "object",
        "description": "A password to be used to authenticate the client's\nidentity.",
        "properties": {
          "cleartext-password": {
            "description": "The cleartext value of the password.",
            "type": "string",
            "example": "Some cleartext-password"
          }
        },
        "xml": {
          "name": "password",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased",
        "type": "object",
        "description": "A locally-defined or referenced asymmetric key\npair to be used for host identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "hostbased",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_hostbased_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate",
        "type": "object",
        "description": "A locally-defined or referenced certificate\nto be used for client identification.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition"
          }
        },
        "required": [
          "inline-definition"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_inline-definition",
        "type": "object",
        "description": "Container to hold the local key definition.",
        "properties": {
          "cleartext-private-key": {
            "description": "The value of the binary key  The key's value is\ninterpreted by the 'private-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "private-key-format": {
            "description": "Identifies the private key's format.  Implementations SHOULD\nensure that the incoming private key value is encoded in the\nspecified format.\n\nFor encrypted keys, the value is the decrypted key's\nformat (i.e., the 'encrypted-value-format' conveys the\nencrypted key's format.",
            "type": "string",
            "enum": [
              "private-key-format",
              "ec-private-key-format",
              "rsa-private-key-format",
              "one-asymmetric-key-format"
            ],
            "example": "private-key-format"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_input": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_input",
        "type": "object",
        "properties": {
          "csr-format": {
            "description": "Specifies the format for the returned certificate.",
            "type": "string",
            "enum": [
              "csr-format",
              "p10-csr-format"
            ],
            "example": "csr-format"
          },
          "csr-info": {
            "description": "A CertificationRequestInfo structure, as defined in\nRFC 2986.\n\nEnables the client to provide a fully-populated\nCertificationRequestInfo structure that the server\nonly needs to sign in order to generate the complete\n'CertificationRequest' structure to return in the\n'output'.\n\nThe 'AlgorithmIdentifier' field contained inside\nthe 'SubjectPublicKeyInfo' field MUST be one known\nto be supported by the device.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "csr-format",
          "csr-info"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_output": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_client-identity_certificate_generate-csr_output",
        "type": "object",
        "properties": {
          "p10-csr": {
            "description": "A CertificationRequest, as defined in RFC 2986.",
            "type": "string",
            "format": "byte"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication",
        "type": "object",
        "description": "Specifies how the SSH client can authenticate SSH servers.\nAny combination of authentication methods is additive and\nunordered.",
        "properties": {
          "ssh-host-keys": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys"
          },
          "ee-certs": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs"
          },
          "ca-certs": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs"
          }
        },
        "xml": {
          "name": "server-authentication",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys",
        "type": "object",
        "description": "A bag of SSH host keys used by the SSH client to\nauthenticate SSH server host keys.  A server host key\nis authenticated if it is an exact match to a\nconfigured SSH host key.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition"
          }
        },
        "xml": {
          "name": "ssh-host-keys",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition",
        "type": "object",
        "description": "A container to hold local public key definitions.",
        "properties": {
          "public-key": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key"
            },
            "description": "A public key definition."
          }
        },
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ssh-host-keys_inline-definition_public-key",
        "type": "object",
        "description": "A public key definition.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this public key.",
            "type": "string",
            "example": "Some name"
          },
          "public-key": {
            "description": "The binary value of the public key.  The interpretation\nof the value is defined by 'public-key-format' field.",
            "type": "string",
            "format": "byte"
          },
          "public-key-format": {
            "description": "Identifies the public key's format. Implementations SHOULD\nensure that the incoming public key value is encoded in the\nspecified format.",
            "type": "string",
            "enum": [
              "public-key-format",
              "subject-public-key-info-format",
              "ssh-public-key-format"
            ],
            "example": "public-key-format"
          }
        },
        "required": [
          "public-key",
          "public-key-format"
        ],
        "xml": {
          "name": "public-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs",
        "type": "object",
        "description": "A set of certificate authority (CA) certificates used by\nthe SSH client to authenticate SSH servers.  A server\nis authenticated if its certificate has a valid chain\nof trust to a configured CA certificate.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition"
          }
        },
        "xml": {
          "name": "ca-certs",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition",
        "type": "object",
        "description": "A container for locally configured trust anchor\ncertificates.",
        "properties": {
          "certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate"
            },
            "description": "A trust anchor certificate or chain of certificates.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "certificate"
        ],
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ca-certs_inline-definition_certificate",
        "type": "object",
        "description": "A trust anchor certificate or chain of certificates.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this certificate.",
            "type": "string",
            "example": "Some name"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "cert-data"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs",
        "type": "object",
        "description": "A set of end-entity certificates used by the SSH client\nto authenticate SSH servers.  A server is authenticated\nif its certificate is an exact match to a configured\nend-entity certificate.",
        "properties": {
          "inline-definition": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition"
          }
        },
        "xml": {
          "name": "ee-certs",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition",
        "type": "object",
        "description": "A container for locally configured trust anchor\ncertificates.",
        "properties": {
          "certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate"
            },
            "description": "A trust anchor certificate or chain of certificates.",
            "example": [
              {
                "name": "Some name"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "certificate"
        ],
        "xml": {
          "name": "inline-definition",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_server-authentication_ee-certs_inline-definition_certificate",
        "type": "object",
        "description": "A trust anchor certificate or chain of certificates.",
        "properties": {
          "name": {
            "description": "An arbitrary name for this certificate.",
            "type": "string",
            "example": "Some name"
          },
          "cert-data": {
            "description": "The binary certificate data for this certificate.",
            "type": "string",
            "format": "byte"
          }
        },
        "required": [
          "cert-data"
        ],
        "xml": {
          "name": "certificate",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params",
        "type": "object",
        "description": "Configurable parameters of the SSH transport layer.",
        "properties": {
          "key-exchange": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange"
          },
          "encryption": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption"
          },
          "host-key": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key"
          },
          "mac": {
            "$ref": "#/components/schemas/ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac"
          }
        },
        "xml": {
          "name": "transport-params",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_host-key",
        "type": "object",
        "description": "Parameters regarding host key.",
        "properties": {
          "host-key-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "public-key-alg-base",
                "x509v3-ecdsa-sha2-1.3.132.0.33",
                "x509v3-ecdsa-sha2-nistp521",
                "x509v3-ecdsa-sha2-1.3.132.0.26",
                "x509v3-ecdsa-sha2-1.3.132.0.38",
                "x509v3-ssh-rsa",
                "spki-sign-dss",
                "ecdsa-sha2-nistp521",
                "ssh-ed448",
                "pgp-sign-rsa",
                "ssh-rsa",
                "rsa-sha2-256",
                "ecdsa-sha2-1.3.132.0.33",
                "x509v3-ecdsa-sha2-1.3.132.0.1",
                "x509v3-ecdsa-sha2-1.3.132.0.27",
                "ecdsa-sha2-1.2.840.10045.3.1.1",
                "x509v3-ecdsa-sha2-1.3.132.0.36",
                "ecdsa-sha2-1.3.132.0.37",
                "x509v3-ecdsa-sha2-nistp384",
                "ecdsa-sha2-1.3.132.0.26",
                "ecdsa-sha2-1.3.132.0.27",
                "x509v3-ecdsa-sha2-nistp256",
                "x509v3-ssh-dss",
                "ssh-ed25519",
                "x509v3-ecdsa-sha2-1.3.132.0.37",
                "ecdsa-sha2-nistp256",
                "pgp-sign-dss",
                "ssh-dss",
                "ecdsa-sha2-1.3.132.0.38",
                "ecdsa-sha2-1.3.132.0.1",
                "rsa-sha2-512",
                "ecdsa-sha2-nistp384",
                "x509v3-ecdsa-sha2-1.3.132.0.16",
                "null",
                "x509v3-rsa2048-sha256",
                "spki-sign-rsa",
                "ecdsa-sha2-1.3.132.0.36",
                "ecdsa-sha2-1.3.132.0.16",
                "x509v3-ecdsa-sha2-1.2.840.10045.3.1.1"
              ],
              "example": "public-key-alg-base"
            },
            "description": "Acceptable host key algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable host key algorithms are implementation-\ndefined."
          }
        },
        "xml": {
          "name": "host-key",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_key-exchange",
        "type": "object",
        "description": "Parameters regarding key exchange.",
        "properties": {
          "key-exchange-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "key-exchange-alg-base",
                "ecdh-sha2-1.3.132.0.38",
                "gss-group1-sha1-1.3.132.0.33",
                "gss-group18-sha512-1.3.132.0.26",
                "gss-group18-sha512-1.3.132.0.33",
                "ecdh-sha2-nistp256",
                "ecdh-sha2-1.2.840.10045.3.1.1",
                "gss-nistp521-sha512-1.3.132.0.37",
                "gss-group17-sha512-nistp521",
                "gss-group14-sha1-1.3.132.0.16",
                "gss-nistp384-sha384-nistp384",
                "gss-curve448-sha512-1.3.132.0.27",
                "gss-group17-sha512-1.3.132.0.38",
                "gss-nistp384-sha384-1.3.132.0.37",
                "gss-group14-sha256-nistp521",
                "gss-group17-sha512-1.3.132.0.16",
                "gss-group1-sha1-1.3.132.0.36",
                "gss-nistp256-sha256-nistp521",
                "ecdh-sha2-nistp521",
                "gss-gex-sha1-1.3.132.0.16",
                "gss-gex-sha1-1.3.132.0.33",
                "gss-group14-sha1-1.3.132.0.33",
                "ecmqv-sha2",
                "gss-group1-sha1-1.3.132.0.38",
                "rsa1024-sha1",
                "gss-group16-sha512-1.3.132.0.1",
                "gss-group1-sha1-1.3.132.0.37",
                "gss-group17-sha512-1.3.132.0.37",
                "gss-group18-sha512-nistp521",
                "diffie-hellman-group15-sha512",
                "gss-nistp384-sha384-1.3.132.0.36",
                "gss-nistp256-sha256-nistp256",
                "gss-curve25519-sha256-nistp521",
                "ecdh-sha2-1.3.132.0.26",
                "gss-group14-sha1-nistp256",
                "gss-group14-sha256-1.3.132.0.27",
                "ext-info-c",
                "gss-group14-sha1-1.3.132.0.1",
                "gss-curve448-sha512-nistp384",
                "gss-group14-sha1-nistp384",
                "gss-group15-sha512-nistp256",
                "gss-group17-sha512-nistp256",
                "gss-curve448-sha512-1.2.840.10045.3.1.1",
                "gss-group15-sha512-1.3.132.0.27",
                "gss-gex-sha1-1.3.132.0.37",
                "gss-group14-sha256-1.3.132.0.38",
                "gss-group15-sha512-1.3.132.0.33",
                "diffie-hellman-group16-sha512",
                "gss-nistp384-sha384-1.3.132.0.26",
                "gss-group15-sha512-1.3.132.0.38",
                "gss-group14-sha256-1.3.132.0.16",
                "diffie-hellman-group18-sha512",
                "gss-group14-sha256-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.3.132.0.27",
                "gss-group15-sha512-nistp521",
                "gss-group15-sha512-1.3.132.0.36",
                "gss-group17-sha512-1.3.132.0.36",
                "gss-nistp384-sha384-nistp256",
                "gss-nistp521-sha512-1.3.132.0.26",
                "gss-nistp256-sha256-1.3.132.0.36",
                "gss-curve448-sha512-1.3.132.0.1",
                "ecdh-sha2-1.3.132.0.36",
                "curve448-sha512",
                "gss-nistp521-sha512-1.3.132.0.16",
                "gss-group14-sha256-1.3.132.0.1",
                "gss-group18-sha512-1.3.132.0.1",
                "gss-nistp521-sha512-1.3.132.0.1",
                "gss-curve448-sha512-nistp521",
                "gss-nistp256-sha256-1.3.132.0.16",
                "gss-curve25519-sha256-1.3.132.0.16",
                "gss-curve25519-sha256-1.3.132.0.38",
                "ecdh-sha2-1.3.132.0.33",
                "gss-gex-sha1-1.3.132.0.36",
                "gss-group16-sha512-1.3.132.0.16",
                "gss-group17-sha512-1.3.132.0.26",
                "diffie-hellman-group14-sha256",
                "diffie-hellman-group14-sha1",
                "ecdh-sha2-1.3.132.0.16",
                "gss-group14-sha1-1.3.132.0.37",
                "gss-curve448-sha512-1.3.132.0.33",
                "gss-curve25519-sha256-1.2.840.10045.3.1.1",
                "gss-nistp256-sha256-1.3.132.0.38",
                "gss-nistp256-sha256-1.2.840.10045.3.1.1",
                "gss-group18-sha512-1.3.132.0.38",
                "ecdh-sha2-1.3.132.0.1",
                "gss-group14-sha256-1.3.132.0.33",
                "gss-group17-sha512-1.3.132.0.1",
                "gss-group18-sha512-1.3.132.0.16",
                "gss-group18-sha512-1.3.132.0.37",
                "gss-nistp521-sha512-1.3.132.0.27",
                "gss-nistp384-sha384-1.3.132.0.1",
                "gss-group16-sha512-nistp384",
                "gss-group15-sha512-nistp384",
                "diffie-hellman-group-exchange-sha1",
                "rsa2048-sha256",
                "gss-group15-sha512-1.3.132.0.26",
                "gss-curve25519-sha256-1.3.132.0.37",
                "diffie-hellman-group1-sha1",
                "gss-gex-sha1-1.3.132.0.26",
                "gss-gex-sha1-1.3.132.0.27",
                "gss-group16-sha512-nistp256",
                "gss-gex-sha1-nistp256",
                "gss-group16-sha512-1.3.132.0.36",
                "curve25519-sha256",
                "gss-group15-sha512-1.3.132.0.16",
                "gss-group1-sha1-1.3.132.0.1",
                "gss-group16-sha512-1.3.132.0.37",
                "gss-nistp256-sha256-1.3.132.0.37",
                "gss-group14-sha1-1.3.132.0.36",
                "gss-gex-sha1-nistp521",
                "gss-nistp384-sha384-1.3.132.0.16",
                "gss-nistp521-sha512-nistp256",
                "gss-curve25519-sha256-1.3.132.0.33",
                "gss-curve25519-sha256-1.3.132.0.1",
                "gss-curve448-sha512-nistp256",
                "gss-nistp256-sha256-1.3.132.0.26",
                "gss-nistp521-sha512-1.3.132.0.36",
                "ext-info-s",
                "gss-curve25519-sha256-nistp384",
                "gss-group18-sha512-nistp384",
                "gss-gex-sha1-1.2.840.10045.3.1.1",
                "gss-gex-sha1-1.3.132.0.1",
                "gss-gex-sha1-1.3.132.0.38",
                "gss-group17-sha512-nistp384",
                "gss-group1-sha1-nistp384",
                "gss-curve448-sha512-1.3.132.0.16",
                "gss-curve448-sha512-1.3.132.0.26",
                "gss-group16-sha512-nistp521",
                "gss-group16-sha512-1.3.132.0.38",
                "gss-group1-sha1-1.3.132.0.26",
                "gss-nistp384-sha384-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.3.132.0.16",
                "gss-group14-sha256-1.3.132.0.36",
                "gss-curve448-sha512-1.3.132.0.37",
                "gss-group14-sha256-1.3.132.0.26",
                "gss-group18-sha512-1.3.132.0.36",
                "ecdh-sha2-nistp384",
                "gss-nistp384-sha384-1.3.132.0.38",
                "gss-",
                "gss-group16-sha512-1.3.132.0.26",
                "gss-group14-sha256-nistp384",
                "gss-curve25519-sha256-1.3.132.0.27",
                "gss-group16-sha512-1.3.132.0.27",
                "gss-group18-sha512-nistp256",
                "gss-nistp384-sha384-1.3.132.0.27",
                "gss-group14-sha256-1.3.132.0.37",
                "gss-group14-sha1-1.2.840.10045.3.1.1",
                "gss-nistp384-sha384-1.3.132.0.33",
                "gss-curve448-sha512-1.3.132.0.38",
                "diffie-hellman-group17-sha512",
                "ecdh-sha2-1.3.132.0.37",
                "gss-nistp256-sha256-1.3.132.0.27",
                "gss-group16-sha512-1.2.840.10045.3.1.1",
                "gss-group16-sha512-1.3.132.0.33",
                "gss-nistp521-sha512-1.3.132.0.38",
                "gss-curve25519-sha256-nistp256",
                "gss-nistp384-sha384-nistp521",
                "gss-nistp256-sha256-1.3.132.0.1",
                "gss-nistp521-sha512-1.2.840.10045.3.1.1",
                "gss-group18-sha512-1.3.132.0.27",
                "gss-curve25519-sha256-1.3.132.0.26",
                "diffie-hellman-group-exchange-sha256",
                "gss-nistp521-sha512-nistp384",
                "gss-group1-sha1-nistp521",
                "gss-gex-sha1-nistp384",
                "gss-group17-sha512-1.2.840.10045.3.1.1",
                "gss-curve25519-sha256-1.3.132.0.36",
                "gss-group14-sha1-1.3.132.0.26",
                "ecdh-sha2-1.3.132.0.27",
                "gss-group17-sha512-1.3.132.0.33",
                "gss-group14-sha256-nistp256",
                "gss-nistp521-sha512-nistp521",
                "gss-group14-sha1-nistp521",
                "gss-curve448-sha512-1.3.132.0.36",
                "gss-group15-sha512-1.3.132.0.1",
                "gss-nistp256-sha256-nistp384",
                "gss-group14-sha1-1.3.132.0.38",
                "gss-group17-sha512-1.3.132.0.27",
                "gss-nistp256-sha256-1.3.132.0.33",
                "gss-nistp521-sha512-1.3.132.0.33",
                "gss-group15-sha512-1.2.840.10045.3.1.1",
                "gss-group1-sha1-1.2.840.10045.3.1.1",
                "gss-group1-sha1-nistp256",
                "gss-group14-sha1-1.3.132.0.27",
                "gss-group18-sha512-1.2.840.10045.3.1.1",
                "gss-group15-sha512-1.3.132.0.37"
              ],
              "example": "key-exchange-alg-base"
            },
            "description": "Acceptable key exchange algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable key exchange algorithms are implementation\ndefined."
          }
        },
        "xml": {
          "name": "key-exchange",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_encryption",
        "type": "object",
        "description": "Parameters regarding encryption.",
        "properties": {
          "encryption-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "encryption-alg-base",
                "arcfour256",
                "aes256-cbc",
                "aes128-ctr",
                "twofish128-ctr",
                "serpent128-ctr",
                "aes128-cbc",
                "cast128-cbc",
                "serpent256-ctr",
                "twofish-cbc",
                "aes192-ctr",
                "serpent192-cbc",
                "none",
                "triple-des-cbc",
                "twofish192-cbc",
                "des-cbc",
                "AEAD_AES_128_GCM",
                "aes192-cbc",
                "blowfish-ctr",
                "blowfish-cbc",
                "twofish192-ctr",
                "twofish256-ctr",
                "twofish128-cbc",
                "idea-cbc",
                "serpent192-ctr",
                "cast128-ctr",
                "AEAD_AES_256_GCM",
                "idea-ctr",
                "arcfour",
                "serpent128-cbc",
                "aes256-ctr",
                "twofish256-cbc",
                "serpent256-cbc",
                "triple-des-ctr",
                "arcfour128"
              ],
              "example": "encryption-alg-base"
            },
            "description": "Acceptable encryption algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable encryption algorithms are implementation\ndefined."
          }
        },
        "xml": {
          "name": "encryption",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_transport-params_mac",
        "type": "object",
        "description": "Parameters regarding message authentication code (MAC).",
        "properties": {
          "mac-alg": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "mac-alg-base",
                "hmac-sha1-96",
                "AEAD_AES_256_GCM",
                "hmac-md5-96",
                "AEAD_AES_128_GCM",
                "hmac-sha1",
                "hmac-sha2-256",
                "hmac-md5",
                "none",
                "hmac-sha2-512"
              ],
              "example": "mac-alg-base"
            },
            "description": "Acceptable MAC algorithms in order of decreasing\npreference.\n\nIf this leaf-list is not configured (has zero elements)\nthe acceptable MAC algorithms are implementation-\ndefined."
          }
        },
        "xml": {
          "name": "mac",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_keepalives": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_ssh-client-parameters_keepalives",
        "type": "object",
        "description": "Configures the keep-alive policy, to proactively test\nthe aliveness of the SSH server.  An unresponsive SSH\nserver is dropped after approximately max-wait *\nmax-attempts seconds.  Per Section 4 of RFC 4254,\nthe SSH client SHOULD send an SSH_MSG_GLOBAL_REQUEST\nmessage with a purposely nonexistent 'request name'\nvalue (e.g., keepalive@ietf.org) and the 'want reply'\nvalue set to '1'.",
        "properties": {
          "max-attempts": {
            "description": "Sets the maximum number of sequential keep-alive\nmessages that can fail to obtain a response from\nthe SSH server before assuming the SSH server is\nno longer alive.",
            "type": "integer",
            "format": "int32",
            "default": 3,
            "example": 0
          },
          "max-wait": {
            "description": "Sets the amount of time in seconds after which if\nno data has been received from the SSH server, a\nSSH-level message will be sent to test the\naliveness of the SSH server.",
            "type": "integer",
            "format": "int32",
            "default": 30,
            "example": 1
          }
        },
        "xml": {
          "name": "keepalives",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_netconf-client-parameters": {
        "title": "ietf-netconf-client_netconf-client_listen_endpoints_endpoint_ssh_netconf-client-parameters",
        "type": "object",
        "description": "NETCONF-level client parameters to listen for\nNETCONF over SSH Call Home connections.",
        "properties": {},
        "xml": {
          "name": "netconf-client-parameters",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-client"
        }
      },
      "ietf-netconf-monitoring_get-schema_input": {
        "title": "ietf-netconf-monitoring_get-schema_input",
        "type": "object",
        "properties": {
          "identifier": {
            "description": "Identifier for the schema list entry.",
            "type": "string",
            "example": "Some identifier"
          },
          "version": {
            "description": "Version of the schema requested.  If this parameter is not\npresent, and more than one version of the schema exists on\nthe server, a 'data-not-unique' error is returned, as\ndescribed above.",
            "type": "string",
            "example": "Some version"
          },
          "format": {
            "description": "The data modeling language of the schema.  If this\nparameter is not present, and more than one formats of\nthe schema exists on the server, a 'data-not-unique' error\nis returned, as described above.",
            "type": "string",
            "enum": [
              "schema-format",
              "yang",
              "yin",
              "xsd",
              "rng",
              "rnc"
            ],
            "example": "schema-format"
          }
        },
        "required": [
          "identifier"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_get-schema_output": {
        "title": "ietf-netconf-monitoring_get-schema_output",
        "type": "object",
        "properties": {
          "data": {
            "description": "Contains the schema content.",
            "example": "<data> ... </data>",
            "type": "string"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state": {
        "title": "ietf-netconf-monitoring_netconf-state",
        "type": "object",
        "description": "The netconf-state container is the root of the monitoring\ndata model.",
        "properties": {
          "sessions": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions"
          },
          "capabilities": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_capabilities"
          },
          "schemas": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas"
          },
          "datastores": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores"
          },
          "statistics": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_statistics"
          }
        },
        "xml": {
          "name": "netconf-state",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_capabilities": {
        "title": "ietf-netconf-monitoring_netconf-state_capabilities",
        "type": "object",
        "description": "Contains the list of NETCONF capabilities supported by the\nserver.",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "List of NETCONF capabilities supported by the server."
          }
        },
        "xml": {
          "name": "capabilities",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_datastores": {
        "title": "ietf-netconf-monitoring_netconf-state_datastores",
        "type": "object",
        "description": "Contains the list of NETCONF configuration datastores.",
        "properties": {
          "datastore": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore"
            },
            "description": "List of NETCONF configuration datastores supported by\nthe NETCONF server and related information."
          }
        },
        "xml": {
          "name": "datastores",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_datastores_datastore": {
        "title": "ietf-netconf-monitoring_netconf-state_datastores_datastore",
        "type": "object",
        "description": "List of NETCONF configuration datastores supported by\nthe NETCONF server and related information.",
        "properties": {
          "name": {
            "description": "Name of the datastore associated with this list entry.",
            "type": "string",
            "enum": [
              "running",
              "candidate",
              "startup"
            ],
            "example": "running"
          },
          "locks": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore_locks"
          }
        },
        "xml": {
          "name": "datastore",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_datastores_datastore_locks": {
        "title": "ietf-netconf-monitoring_netconf-state_datastores_datastore_locks",
        "type": "object",
        "description": "The NETCONF <lock> and <partial-lock> operations allow\na client to lock specific resources in a datastore.  The\nNETCONF server will prevent changes to the locked\nresources by all sessions except the one that acquired\nthe lock(s).\n\nMonitoring information is provided for each datastore\nentry including details such as the session that acquired\nthe lock, the type of lock (global or partial) and the\nlist of locked resources.  Multiple locks per datastore\nare supported.",
        "properties": {
          "global-lock": {
            "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_datastores_datastore_locks_global-lock"
          }
        },
        "required": [
          "global-lock"
        ],
        "xml": {
          "name": "locks",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_datastores_datastore_locks_global-lock": {
        "title": "ietf-netconf-monitoring_netconf-state_datastores_datastore_locks_global-lock",
        "type": "object",
        "description": "Present if the global lock is set.",
        "properties": {
          "locked-time": {
            "description": "The date and time of when the resource was\nlocked.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "locked-by-session": {
            "description": "The session ID of the session that has locked\nthis resource.  Both a global lock and a partial\nlock MUST contain the NETCONF session-id.\n\nIf the lock is held by a session that is not managed\nby the NETCONF server (e.g., a CLI session), a session\nid of 0 (zero) is reported.",
            "type": "integer",
            "format": "int64",
            "example": 0
          }
        },
        "required": [
          "locked-time",
          "locked-by-session"
        ],
        "xml": {
          "name": "global-lock",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_schemas": {
        "title": "ietf-netconf-monitoring_netconf-state_schemas",
        "type": "object",
        "description": "Contains the list of data model schemas supported by the\nserver.",
        "properties": {
          "schema": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_schemas_schema"
            },
            "description": "List of data model schemas supported by the server."
          }
        },
        "xml": {
          "name": "schemas",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_schemas_schema": {
        "title": "ietf-netconf-monitoring_netconf-state_schemas_schema",
        "type": "object",
        "description": "List of data model schemas supported by the server.",
        "properties": {
          "identifier": {
            "description": "Identifier to uniquely reference the schema.  The\nidentifier is used in the <get-schema> operation and may\nbe used for other purposes such as file retrieval.\n\nFor modeling languages that support or require a data\nmodel name (e.g., YANG module name) the identifier MUST\nmatch that name.  For YANG data models, the identifier is\nthe name of the module or submodule.  In other cases, an\nidentifier such as a filename MAY be used instead.",
            "type": "string",
            "example": "Some identifier"
          },
          "format": {
            "description": "The data modeling language the schema is written\nin (currently xsd, yang, yin, rng, or rnc).\nFor YANG data models, 'yang' format MUST be supported and\n'yin' format MAY also be provided.",
            "type": "string",
            "enum": [
              "schema-format",
              "yang",
              "yin",
              "xsd",
              "rng",
              "rnc"
            ],
            "example": "schema-format"
          },
          "namespace": {
            "description": "The XML namespace defined by the data model.\n\nFor YANG data models, this is the module's namespace.\nIf the list entry describes a submodule, this field\ncontains the namespace of the module to which the\nsubmodule belongs.",
            "type": "string",
            "example": "Some namespace"
          },
          "location": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "NETCONF"
              ],
              "example": "NETCONF"
            },
            "description": "One or more locations from which the schema can be\nretrieved.  This list SHOULD contain at least one\nentry per schema.\n\nA schema entry may be located on a remote file system\n(e.g., reference to file system for ftp retrieval) or\nretrieved directly from a server supporting the\n<get-schema> operation (denoted by the value 'NETCONF')."
          },
          "version": {
            "description": "Version of the schema supported.  Multiple versions MAY be\nsupported simultaneously by a NETCONF server.  Each\nversion MUST be reported individually in the schema list,\ni.e., with same identifier, possibly different location,\nbut different version.\n\nFor YANG data models, version is the value of the most\nrecent YANG 'revision' statement in the module or\nsubmodule, or the empty string if no 'revision' statement\nis present.",
            "type": "string",
            "example": "Some version"
          }
        },
        "required": [
          "namespace"
        ],
        "xml": {
          "name": "schema",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_sessions": {
        "title": "ietf-netconf-monitoring_netconf-state_sessions",
        "type": "object",
        "description": "The sessions container includes session-specific data for\nNETCONF management sessions.  The session list MUST include\nall currently active NETCONF sessions.",
        "properties": {
          "session": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-netconf-monitoring_netconf-state_sessions_session"
            },
            "description": "All NETCONF sessions managed by the NETCONF server\nMUST be reported in this list."
          }
        },
        "xml": {
          "name": "sessions",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_sessions_session": {
        "title": "ietf-netconf-monitoring_netconf-state_sessions_session",
        "type": "object",
        "description": "All NETCONF sessions managed by the NETCONF server\nMUST be reported in this list.",
        "properties": {
          "source-host": {
            "description": "Host identifier of the NETCONF client.  The value\nreturned is implementation specific (e.g., hostname,\nIPv4 address, IPv6 address)",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "login-time": {
            "description": "Time at the server at which the session was established.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "in-rpcs": {
            "description": "Number of correct <rpc> messages received.",
            "type": "string",
            "default": "0"
          },
          "out-rpc-errors": {
            "description": "Number of <rpc-reply> messages sent that contained an\n<rpc-error> element.",
            "type": "string",
            "default": "0"
          },
          "in-bad-rpcs": {
            "description": "Number of messages received when an <rpc> message was expected,\nthat were not correct <rpc> messages.  This includes XML parse\nerrors and errors on the rpc layer.",
            "type": "string",
            "default": "0"
          },
          "out-notifications": {
            "description": "Number of <notification> messages sent.",
            "type": "string",
            "default": "0"
          },
          "transport": {
            "description": "Identifies the transport for each session, e.g.,\n'netconf-ssh', 'netconf-soap', etc.",
            "type": "string",
            "enum": [
              "transport",
              "netconf-ssh",
              "netconf-tls",
              "netconf-beep",
              "netconf-soap-over-beep",
              "netconf-soap-over-https"
            ],
            "example": "transport"
          },
          "session-id": {
            "description": "Unique identifier for the session.  This value is the\nNETCONF session identifier, as defined in RFC 4741.",
            "type": "integer",
            "format": "int64",
            "example": 1
          },
          "username": {
            "description": "The username is the client identity that was authenticated\nby the NETCONF transport protocol.  The algorithm used to\nderive the username is NETCONF transport protocol specific\nand in addition specific to the authentication mechanism\nused by the NETCONF transport protocol.",
            "type": "string",
            "example": "Some username"
          }
        },
        "required": [
          "login-time",
          "transport",
          "username"
        ],
        "xml": {
          "name": "session",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-monitoring_netconf-state_statistics": {
        "title": "ietf-netconf-monitoring_netconf-state_statistics",
        "type": "object",
        "description": "Statistical data pertaining to the NETCONF server.",
        "properties": {
          "netconf-start-time": {
            "description": "Date and time at which the management subsystem was\nstarted.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "in-rpcs": {
            "description": "Number of correct <rpc> messages received.",
            "type": "string",
            "default": "0"
          },
          "in-sessions": {
            "description": "Number of sessions started.  This counter is incremented\nwhen a <hello> message with a <session-id> is sent.\n\n'in-sessions' - 'in-bad-hellos' =\n 'number of correctly started netconf sessions'",
            "type": "string",
            "default": "0"
          },
          "out-rpc-errors": {
            "description": "Number of <rpc-reply> messages sent that contained an\n<rpc-error> element.",
            "type": "string",
            "default": "0"
          },
          "in-bad-hellos": {
            "description": "Number of sessions silently dropped because an\ninvalid <hello> message was received.  This includes <hello>\nmessages with a 'session-id' attribute, bad namespace, and\nbad capability declarations.",
            "type": "string",
            "default": "0"
          },
          "in-bad-rpcs": {
            "description": "Number of messages received when an <rpc> message was expected,\nthat were not correct <rpc> messages.  This includes XML parse\nerrors and errors on the rpc layer.",
            "type": "string",
            "default": "0"
          },
          "out-notifications": {
            "description": "Number of <notification> messages sent.",
            "type": "string",
            "default": "0"
          },
          "dropped-sessions": {
            "description": "Number of sessions that were abnormally terminated, e.g.,\ndue to idle timeout or transport close.  This counter is not\nincremented when a session is properly closed by a\n<close-session> operation, or killed by a <kill-session>\noperation.",
            "type": "string",
            "default": "0"
          }
        },
        "xml": {
          "name": "statistics",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring"
        }
      },
      "ietf-netconf-nmda_get-data_input": {
        "title": "ietf-netconf-nmda_get-data_input",
        "type": "object",
        "properties": {
          "datastore": {
            "description": "Datastore from which to retrieve data.\n\nIf the datastore is not supported by the server, then the\nserver MUST return an <rpc-error> element with an\n<error-tag> value of 'invalid-value'.",
            "type": "string",
            "enum": [
              "datastore",
              "dynamic",
              "conventional",
              "intended",
              "startup",
              "running",
              "candidate",
              "operational"
            ],
            "example": "datastore"
          },
          "subtree-filter": {
            "description": "This parameter identifies the portions of the\ntarget datastore to retrieve.",
            "example": "<subtree-filter> ... </subtree-filter>",
            "type": "string"
          },
          "config-filter": {
            "description": "Filter for nodes with the given value for their 'config'\nproperty.  When this leaf is set to 'true', only 'config\ntrue' nodes are selected, and when set to 'false', only\n'config false' nodes are selected.  If this leaf is not\npresent, no nodes are filtered.",
            "type": "boolean",
            "example": true
          },
          "origin-filter": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "origin",
                "default",
                "learned",
                "dynamic",
                "system",
                "unknown",
                "intended"
              ],
              "example": "origin"
            },
            "description": "Filter based on the 'origin' annotation.  A\nconfiguration node matches the filter if its 'origin'\nannotation is derived from or equal to any of the given\nfilter values."
          },
          "max-depth": {
            "description": "For each node selected by the filters, this parameter\nselects how many conceptual subtree levels should be\nreturned in the reply.  If the depth is 1, the reply\nincludes just the selected nodes but no children.  If the\ndepth is 'unbounded', all descendant nodes are included.",
            "type": "integer",
            "format": "int32",
            "default": "unbounded",
            "example": 1
          },
          "with-origin": {
            "description": "If this parameter is present, the server will return\nthe 'origin' annotation for the nodes that have one.",
            "type": "object"
          },
          "with-defaults": {
            "description": "The explicit defaults processing mode requested.",
            "type": "string",
            "enum": [
              "report-all",
              "report-all-tagged",
              "trim",
              "explicit"
            ],
            "example": "report-all"
          }
        },
        "required": [
          "datastore"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-nmda"
        }
      },
      "ietf-netconf-nmda_get-data_output": {
        "title": "ietf-netconf-nmda_get-data_output",
        "type": "object",
        "properties": {
          "data": {
            "description": "Copy of the source datastore subset that matched\nthe filter criteria (if any).  An empty data\ncontainer indicates that the request did not\nproduce any results.",
            "example": "<data> ... </data>",
            "type": "string"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-nmda"
        }
      },
      "ietf-netconf-nmda_edit-data_input": {
        "title": "ietf-netconf-nmda_edit-data_input",
        "type": "object",
        "properties": {
          "datastore": {
            "description": "Datastore that is the target of the <edit-data> operation.\n\nIf the target datastore is not writable, or is not\nsupported by the server, then the server MUST return an\n<rpc-error> element with an <error-tag> value of\n'invalid-value'.",
            "type": "string",
            "enum": [
              "datastore",
              "dynamic",
              "conventional",
              "intended",
              "startup",
              "running",
              "candidate",
              "operational"
            ],
            "example": "datastore"
          },
          "default-operation": {
            "description": "The default operation to use.",
            "type": "string",
            "enum": [
              "merge",
              "replace",
              "none"
            ],
            "default": "merge",
            "example": "merge"
          },
          "config": {
            "description": "Inline config content.",
            "example": "<config> ... </config>",
            "type": "string"
          }
        },
        "required": [
          "datastore"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-netconf-nmda"
        }
      },
      "ietf-restconf-monitoring_restconf-state": {
        "title": "ietf-restconf-monitoring_restconf-state",
        "type": "object",
        "description": "Contains RESTCONF protocol monitoring information.",
        "properties": {
          "capabilities": {
            "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_capabilities"
          },
          "streams": {
            "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams"
          }
        },
        "xml": {
          "name": "restconf-state",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring"
        }
      },
      "ietf-restconf-monitoring_restconf-state_capabilities": {
        "title": "ietf-restconf-monitoring_restconf-state_capabilities",
        "type": "object",
        "description": "Contains a list of protocol capability URIs.",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "A RESTCONF protocol capability URI."
          }
        },
        "xml": {
          "name": "capabilities",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring"
        }
      },
      "ietf-restconf-monitoring_restconf-state_streams": {
        "title": "ietf-restconf-monitoring_restconf-state_streams",
        "type": "object",
        "description": "Container representing the notification event streams\nsupported by the server.",
        "properties": {
          "stream": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream"
            },
            "description": "Each entry describes an event stream supported by\nthe server."
          }
        },
        "xml": {
          "name": "streams",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring"
        }
      },
      "ietf-restconf-monitoring_restconf-state_streams_stream": {
        "title": "ietf-restconf-monitoring_restconf-state_streams_stream",
        "type": "object",
        "description": "Each entry describes an event stream supported by\nthe server.",
        "properties": {
          "access": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-restconf-monitoring_restconf-state_streams_stream_access"
            },
            "description": "The server will create an entry in this list for each\nencoding format that is supported for this stream.\nThe media type 'text/event-stream' is expected\nfor all event streams.  This list identifies the\nsubtypes supported for this stream.",
            "example": [
              {
                "location": "Some location",
                "encoding": "Some encoding"
              }
            ],
            "minItems": 1
          },
          "replay-support": {
            "description": "Indicates if replay buffer is supported for this stream.\nIf 'true', then the server MUST support the 'start-time'\nand 'stop-time' query parameters for this stream.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "name": {
            "description": "The stream name.",
            "type": "string",
            "example": "Some name"
          },
          "description": {
            "description": "Description of stream content.",
            "type": "string",
            "example": "Some description"
          },
          "replay-log-creation-time": {
            "description": "Indicates the time the replay log for this stream\nwas created.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "access"
        ],
        "xml": {
          "name": "stream",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring"
        }
      },
      "ietf-restconf-monitoring_restconf-state_streams_stream_access": {
        "title": "ietf-restconf-monitoring_restconf-state_streams_stream_access",
        "type": "object",
        "description": "The server will create an entry in this list for each\nencoding format that is supported for this stream.\nThe media type 'text/event-stream' is expected\nfor all event streams.  This list identifies the\nsubtypes supported for this stream.",
        "properties": {
          "location": {
            "description": "Contains a URL that represents the entry point\nfor establishing notification delivery via\nserver-sent events.",
            "type": "string",
            "example": "Some location"
          },
          "encoding": {
            "description": "This is the secondary encoding format within the\n'text/event-stream' encoding used by all streams.\nThe type 'xml' is supported for XML encoding.\nThe type 'json' is supported for JSON encoding.",
            "type": "string",
            "example": "Some encoding"
          }
        },
        "required": [
          "location"
        ],
        "xml": {
          "name": "access",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-restconf-monitoring"
        }
      },
      "ietf-yang-library_yang-library": {
        "title": "ietf-yang-library_yang-library",
        "type": "object",
        "description": "Container holding the entire YANG library of this server.",
        "properties": {
          "schema": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_schema"
            },
            "description": "A datastore schema that may be used by one or more\ndatastores.\n\nThe schema must be valid and referentially complete, i.e.,\nit must contain modules to satisfy all used import\nstatements for all modules specified in the schema."
          },
          "module-set": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set"
            },
            "description": "A set of modules that may be used by one or more schemas.\n\nA module set does not have to be referentially complete,\ni.e., it may define modules that contain import statements\nfor other modules not included in the module set."
          },
          "datastore": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_datastore"
            },
            "description": "A datastore supported by this server.\n\nEach datastore indicates which schema it supports.\n\nThe server MUST instantiate one entry in this list per\nspecific datastore it supports.\nEach datastore entry with the same datastore schema SHOULD\nreference the same schema."
          },
          "content-id": {
            "description": "A server-generated identifier of the contents of the\n'/yang-library' tree.  The server MUST change the value of\nthis leaf if the information represented by the\n'/yang-library' tree, except '/yang-library/content-id', has\nchanged.",
            "type": "string",
            "example": "Some content-id"
          }
        },
        "required": [
          "content-id"
        ],
        "xml": {
          "name": "yang-library",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_module-set": {
        "title": "ietf-yang-library_yang-library_module-set",
        "type": "object",
        "description": "A set of modules that may be used by one or more schemas.\n\nA module set does not have to be referentially complete,\ni.e., it may define modules that contain import statements\nfor other modules not included in the module set.",
        "properties": {
          "import-only-module": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module"
            },
            "description": "An entry in this list indicates that the server imports\nreusable definitions from the specified revision of the\nmodule but does not implement any protocol-accessible\nobjects from this revision.\n\nMultiple entries for the same module name MAY exist.  This\ncan occur if multiple modules import the same module but\nspecify different revision dates in the import statements."
          },
          "module": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module"
            },
            "description": "An entry in this list represents a module implemented by the\nserver, as per Section 5.6.5 of RFC 7950, with a particular\nset of supported features and deviations."
          },
          "name": {
            "description": "An arbitrary name of the module set.",
            "type": "string",
            "example": "Some name"
          }
        },
        "xml": {
          "name": "module-set",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_module-set_module": {
        "title": "ietf-yang-library_yang-library_module-set_module",
        "type": "object",
        "description": "An entry in this list represents a module implemented by the\nserver, as per Section 5.6.5 of RFC 7950, with a particular\nset of supported features and deviations.",
        "properties": {
          "feature": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "A",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "List of all YANG feature names from this module that are\nsupported by the server, regardless whether they are defined\nin the module or any included submodule."
          },
          "namespace": {
            "description": "The XML namespace identifier for this module.",
            "type": "string",
            "example": "Some namespace"
          },
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "submodule": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_module_submodule"
            },
            "description": "Each entry represents one submodule within the\nparent module."
          },
          "location": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some location"
            },
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry."
          },
          "deviation": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "A",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "List of all YANG deviation modules used by this server to\nmodify the conformance of the module associated with this\nentry.  Note that the same module can be used for deviations\nfor multiple modules, so the same entry MAY appear within\nmultiple 'module' entries.\n\nThis reference MUST NOT (directly or indirectly)\nrefer to the module being deviated.\n\nRobust clients may want to make sure that they handle a\nsituation where a module deviates itself (directly or\nindirectly) gracefully."
          },
          "revision": {
            "description": "The YANG module or submodule revision date.  If no revision\nstatement is present in the YANG module or submodule, this\nleaf is not instantiated.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "namespace",
          "name"
        ],
        "xml": {
          "name": "module",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_module-set_module_submodule": {
        "title": "ietf-yang-library_yang-library_module-set_module_submodule",
        "type": "object",
        "description": "Each entry represents one submodule within the\nparent module.",
        "properties": {
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "location": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some location"
            },
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry."
          },
          "revision": {
            "description": "The YANG module or submodule revision date.  If no revision\nstatement is present in the YANG module or submodule, this\nleaf is not instantiated.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "name"
        ],
        "xml": {
          "name": "submodule",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_module-set_import-only-module": {
        "title": "ietf-yang-library_yang-library_module-set_import-only-module",
        "type": "object",
        "description": "An entry in this list indicates that the server imports\nreusable definitions from the specified revision of the\nmodule but does not implement any protocol-accessible\nobjects from this revision.\n\nMultiple entries for the same module name MAY exist.  This\ncan occur if multiple modules import the same module but\nspecify different revision dates in the import statements.",
        "properties": {
          "name": {
            "description": "The YANG module name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "namespace": {
            "description": "The XML namespace identifier for this module.",
            "type": "string",
            "example": "Some namespace"
          },
          "submodule": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_yang-library_module-set_import-only-module_submodule"
            },
            "description": "Each entry represents one submodule within the\nparent module."
          },
          "location": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some location"
            },
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry."
          },
          "revision": {
            "description": "The YANG module revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "namespace"
        ],
        "xml": {
          "name": "import-only-module",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_module-set_import-only-module_submodule": {
        "title": "ietf-yang-library_yang-library_module-set_import-only-module_submodule",
        "type": "object",
        "description": "Each entry represents one submodule within the\nparent module.",
        "properties": {
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "location": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some location"
            },
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry."
          },
          "revision": {
            "description": "The YANG module or submodule revision date.  If no revision\nstatement is present in the YANG module or submodule, this\nleaf is not instantiated.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "name"
        ],
        "xml": {
          "name": "submodule",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_schema": {
        "title": "ietf-yang-library_yang-library_schema",
        "type": "object",
        "description": "A datastore schema that may be used by one or more\ndatastores.\n\nThe schema must be valid and referentially complete, i.e.,\nit must contain modules to satisfy all used import\nstatements for all modules specified in the schema.",
        "properties": {
          "module-set": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some module-set"
            },
            "description": "A set of module-sets that are included in this schema.\nIf a non-import-only module appears in multiple module\nsets, then the module revision and the associated features\nand deviations must be identical."
          },
          "name": {
            "description": "An arbitrary name of the schema.",
            "type": "string",
            "example": "Some name"
          }
        },
        "xml": {
          "name": "schema",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_yang-library_datastore": {
        "title": "ietf-yang-library_yang-library_datastore",
        "type": "object",
        "description": "A datastore supported by this server.\n\nEach datastore indicates which schema it supports.\n\nThe server MUST instantiate one entry in this list per\nspecific datastore it supports.\nEach datastore entry with the same datastore schema SHOULD\nreference the same schema.",
        "properties": {
          "schema": {
            "description": "A reference to the schema supported by this datastore.\nAll non-import-only modules of the schema are implemented\nwith their associated features and deviations.",
            "type": "string",
            "example": "Some schema"
          },
          "name": {
            "description": "The identity of the datastore.",
            "type": "string",
            "enum": [
              "datastore",
              "dynamic",
              "conventional",
              "intended",
              "startup",
              "running",
              "candidate",
              "operational"
            ],
            "example": "datastore"
          }
        },
        "required": [
          "schema"
        ],
        "xml": {
          "name": "datastore",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_modules-state": {
        "title": "ietf-yang-library_modules-state",
        "type": "object",
        "description": "Contains YANG module monitoring information.",
        "properties": {
          "module-set-id": {
            "description": "Contains a server-specific identifier representing\nthe current set of modules and submodules.  The\nserver MUST change the value of this leaf if the\ninformation represented by the 'module' list instances\nhas changed.",
            "type": "string",
            "example": "Some module-set-id"
          },
          "module": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_modules-state_module"
            },
            "description": "Each entry represents one revision of one module\ncurrently supported by the server."
          }
        },
        "required": [
          "module-set-id"
        ],
        "xml": {
          "name": "modules-state",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_modules-state_module": {
        "title": "ietf-yang-library_modules-state_module",
        "type": "object",
        "description": "Each entry represents one revision of one module\ncurrently supported by the server.",
        "properties": {
          "conformance-type": {
            "description": "Indicates the type of conformance the server is claiming\nfor the YANG module identified by this entry.",
            "type": "string",
            "enum": [
              "implement",
              "import"
            ],
            "example": "implement"
          },
          "schema": {
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry.",
            "type": "string",
            "example": "Some schema"
          },
          "feature": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "A",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "List of YANG feature names from this module that are\nsupported by the server, regardless of whether they are\ndefined in the module or any included submodule."
          },
          "namespace": {
            "description": "The XML namespace identifier for this module.",
            "type": "string",
            "example": "Some namespace"
          },
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "submodule": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_submodule"
            },
            "description": "Each entry represents one submodule within the\nparent module."
          },
          "deviation": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ietf-yang-library_modules-state_module_deviation"
            },
            "description": "List of YANG deviation module names and revisions\nused by this server to modify the conformance of\nthe module associated with this entry.  Note that\nthe same module can be used for deviations for\nmultiple modules, so the same entry MAY appear\nwithin multiple 'module' entries.\n\nThe deviation module MUST be present in the 'module'\nlist, with the same name and revision values.\nThe 'conformance-type' value will be 'implement' for\nthe deviation module."
          },
          "revision": {
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "conformance-type",
          "namespace"
        ],
        "xml": {
          "name": "module",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_modules-state_module_deviation": {
        "title": "ietf-yang-library_modules-state_module_deviation",
        "type": "object",
        "description": "List of YANG deviation module names and revisions\nused by this server to modify the conformance of\nthe module associated with this entry.  Note that\nthe same module can be used for deviations for\nmultiple modules, so the same entry MAY appear\nwithin multiple 'module' entries.\n\nThe deviation module MUST be present in the 'module'\nlist, with the same name and revision values.\nThe 'conformance-type' value will be 'implement' for\nthe deviation module.",
        "properties": {
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "revision": {
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "xml": {
          "name": "deviation",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "ietf-yang-library_modules-state_module_submodule": {
        "title": "ietf-yang-library_modules-state_module_submodule",
        "type": "object",
        "description": "Each entry represents one submodule within the\nparent module.",
        "properties": {
          "schema": {
            "description": "Contains a URL that represents the YANG schema\nresource for this module or submodule.\n\nThis leaf will only be present if there is a URL\navailable for retrieval of the schema for this entry.",
            "type": "string",
            "example": "Some schema"
          },
          "name": {
            "description": "The YANG module or submodule name.",
            "type": "string",
            "example": "A",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "revision": {
            "description": "The YANG module or submodule revision date.\nA zero-length string is used if no revision statement\nis present in the YANG module or submodule.",
            "type": "string",
            "example": "0000-00-00",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "xml": {
          "name": "submodule",
          "namespace": "urn:ietf:params:xml:ns:yang:ietf-yang-library"
        }
      },
      "instance-identifier-patch-module_patch-cont": {
        "title": "instance-identifier-patch-module_patch-cont",
        "type": "object",
        "properties": {
          "case-leaf1": {
            "description": "",
            "type": "string",
            "example": "Some case-leaf1"
          },
          "leaf1": {
            "description": "",
            "type": "string",
            "example": "Some leaf1",
            "xml": {
              "name": "leaf1",
              "namespace": "augment:instance:identifier:patch:module"
            }
          },
          "case-leaf11": {
            "description": "",
            "type": "string",
            "example": "Some case-leaf11"
          },
          "patch-cont2": {
            "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_patch-cont2"
          },
          "my-list1": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1"
            },
            "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1"
          }
        },
        "xml": {
          "name": "patch-cont",
          "namespace": "instance:identifier:patch:module"
        }
      },
      "instance-identifier-patch-module_patch-cont_patch-cont2": {
        "title": "instance-identifier-patch-module_patch-cont_patch-cont2",
        "type": "object",
        "properties": {
          "cont-leaf": {
            "description": "",
            "type": "string",
            "example": "Some cont-leaf"
          }
        },
        "xml": {
          "name": "patch-cont2",
          "namespace": "instance:identifier:patch:module"
        }
      },
      "instance-identifier-patch-module_patch-cont_my-list1": {
        "title": "instance-identifier-patch-module_patch-cont_my-list1",
        "type": "object",
        "description": "PATCH /restconf/config/instance-identifier-patch-module:patch-cont/my-list1/leaf1",
        "properties": {
          "my-leaf12": {
            "description": "",
            "type": "string",
            "example": "Some my-leaf12"
          },
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "my-list2": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/instance-identifier-patch-module_patch-cont_my-list1_my-list2"
            },
            "description": ""
          },
          "my-leaf11": {
            "description": "",
            "type": "string",
            "example": "Some my-leaf11"
          }
        },
        "xml": {
          "name": "my-list1",
          "namespace": "instance:identifier:patch:module"
        }
      },
      "instance-identifier-patch-module_patch-cont_my-list1_my-list2": {
        "title": "instance-identifier-patch-module_patch-cont_my-list1_my-list2",
        "type": "object",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "my-leaf21": {
            "description": "",
            "type": "string",
            "example": "Some my-leaf21"
          },
          "my-leaf22": {
            "description": "",
            "type": "string",
            "example": "Some my-leaf22"
          }
        },
        "xml": {
          "name": "my-list2",
          "namespace": "instance:identifier:patch:module"
        }
      },
      "nc-notifications_netconf": {
        "title": "nc-notifications_netconf",
        "type": "object",
        "description": "Top-level element in the notification namespace",
        "properties": {
          "streams": {
            "$ref": "#/components/schemas/nc-notifications_netconf_streams"
          }
        },
        "xml": {
          "name": "netconf",
          "namespace": "urn:ietf:params:xml:ns:netmod:notification"
        }
      },
      "nc-notifications_netconf_streams": {
        "title": "nc-notifications_netconf_streams",
        "type": "object",
        "description": "The list of event streams supported by the system. When\na query is issued, the returned set of streams is\ndetermined based on user privileges.",
        "properties": {
          "stream": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nc-notifications_netconf_streams_stream"
            },
            "description": "Stream name, description and other information.",
            "example": [
              {
                "name": "Some name",
                "replaySupport": true,
                "description": "Some description",
                "replayLogCreationTime": "0000-00-00T00:00:00Z"
              }
            ],
            "minItems": 1
          }
        },
        "required": [
          "stream"
        ],
        "xml": {
          "name": "streams",
          "namespace": "urn:ietf:params:xml:ns:netmod:notification"
        }
      },
      "nc-notifications_netconf_streams_stream": {
        "title": "nc-notifications_netconf_streams_stream",
        "type": "object",
        "description": "Stream name, description and other information.",
        "properties": {
          "name": {
            "description": "The name of the event stream. If this is the default\nNETCONF stream, this must have the value 'NETCONF'.",
            "type": "string",
            "example": "Some name"
          },
          "replaySupport": {
            "description": "A description of the event stream, including such\ninformation as the type of events that are sent over\nthis stream.",
            "type": "boolean",
            "example": true
          },
          "description": {
            "description": "A description of the event stream, including such\ninformation as the type of events that are sent over\nthis stream.",
            "type": "string",
            "example": "Some description"
          },
          "replayLogCreationTime": {
            "description": "The timestamp of the creation of the log used to support\nthe replay function on this stream. Note that this might\nbe earlier then the earliest available notification in\nthe log. This object is updated if the log resets for\nsome reason.  This object MUST be present if replay is\nsupported.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "required": [
          "replaySupport",
          "description"
        ],
        "xml": {
          "name": "stream",
          "namespace": "urn:ietf:params:xml:ns:netmod:notification"
        }
      },
      "netconf-keystore_add-keystore-entry_input": {
        "title": "netconf-keystore_add-keystore-entry_input",
        "type": "object",
        "properties": {
          "key-credential": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_key-credential"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_key-credential": {
        "title": "netconf-keystore_key-credential",
        "type": "object",
        "properties": {
          "key-id": {
            "description": "",
            "type": "string",
            "example": "Some key-id"
          },
          "private-key": {
            "description": "Base64 encoded private key that should be used for authentication with a netconf device.\nDo not include a public key as that is calculated from the private key.\nUsed for RPCs only. Will encrypt the key before the entry is written into the data store.",
            "type": "string",
            "example": "Some private-key"
          },
          "passphrase": {
            "description": "If the provided key is encrypted by a passphrase this needs to be included. Leave empty\nif the key does not have a passphrase.\nUsed for RPCs only. Will encrypt the passphrase before the entry is written into the data\nstore.",
            "type": "string",
            "example": "Some passphrase"
          }
        },
        "xml": {
          "name": "key-credential",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_remove-keystore-entry_input": {
        "title": "netconf-keystore_remove-keystore-entry_input",
        "type": "object",
        "properties": {
          "key-id": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some key-id"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_add-private-key_input": {
        "title": "netconf-keystore_add-private-key_input",
        "type": "object",
        "properties": {
          "private-key": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_private-key"
            },
            "description": "A private key."
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_private-key": {
        "title": "netconf-keystore_private-key",
        "type": "object",
        "description": "A private key.",
        "properties": {
          "data": {
            "description": "Base64 encoded private key.",
            "type": "string",
            "example": "Some data"
          },
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "certificate-chain": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some certificate-chain"
            },
            "description": "A certificate chain for this public key. Each certificate is an X.509 v3 certificate\nstructure as specified by RFC5280, encoded using the Base64 format."
          }
        },
        "xml": {
          "name": "private-key",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_remove-private-key_input": {
        "title": "netconf-keystore_remove-private-key_input",
        "type": "object",
        "properties": {
          "name": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some name"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_add-trusted-certificate_input": {
        "title": "netconf-keystore_add-trusted-certificate_input",
        "type": "object",
        "properties": {
          "trusted-certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_trusted-certificate"
            },
            "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers."
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_trusted-certificate": {
        "title": "netconf-keystore_trusted-certificate",
        "type": "object",
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "certificate": {
            "description": "An X.509 v3 certificate structure as specified by RFC5280, encoded using\nthe Base64 format.",
            "type": "string",
            "example": "Some certificate"
          }
        },
        "xml": {
          "name": "trusted-certificate",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_remove-trusted-certificate_input": {
        "title": "netconf-keystore_remove-trusted-certificate_input",
        "type": "object",
        "properties": {
          "name": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some name"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_keystore": {
        "title": "netconf-keystore_keystore",
        "type": "object",
        "properties": {
          "key-credential": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_keystore_key-credential"
            },
            "description": ""
          },
          "private-key": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_keystore_private-key"
            },
            "description": "A private key."
          },
          "trusted-certificate": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/netconf-keystore_keystore_trusted-certificate"
            },
            "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers."
          }
        },
        "xml": {
          "name": "keystore",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_keystore_key-credential": {
        "title": "netconf-keystore_keystore_key-credential",
        "type": "object",
        "properties": {
          "key-id": {
            "description": "",
            "type": "string",
            "example": "Some key-id"
          },
          "private-key": {
            "description": "Binary array of Base64 encoded private key that should be used for authentication with a\nnetconf device. Do not include a public key as that is calculated from the private key.\nUsed for writing directly into the data store, encrypted key expected.",
            "type": "string",
            "format": "byte"
          },
          "passphrase": {
            "description": "If the provided key is encrypted by a passphrase this needs to be included. Leave empty\nif the key does not have a passphrase.\nUsed for writing directly into the data store, encrypted passphrase expected.",
            "type": "string",
            "format": "byte"
          }
        },
        "xml": {
          "name": "key-credential",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_keystore_private-key": {
        "title": "netconf-keystore_keystore_private-key",
        "type": "object",
        "description": "A private key.",
        "properties": {
          "data": {
            "description": "Binary array of Base64 encoded private key.",
            "type": "string",
            "format": "byte"
          },
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "certificate-chain": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "byte"
            },
            "description": "A certificate chain for this public key. Each certificate is an X.509 v3 certificate\nstructure as specified by RFC5280, binary data encoded using the Base64 format."
          }
        },
        "xml": {
          "name": "private-key",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-keystore_keystore_trusted-certificate": {
        "title": "netconf-keystore_keystore_trusted-certificate",
        "type": "object",
        "description": "A list of trusted certificate. These certificates can be used by a server to authenticate\nclients, or by clients to authenticate servers.",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          },
          "certificate": {
            "description": "An X.509 v3 certificate structure as specified by RFC5280, binary data encoded using\nthe Base64 format.",
            "type": "string",
            "format": "byte"
          }
        },
        "xml": {
          "name": "trusted-certificate",
          "namespace": "urn:opendaylight:netconf:keystore"
        }
      },
      "netconf-node-topology_create-device_input": {
        "title": "netconf-node-topology_create-device_input",
        "type": "object",
        "properties": {
          "login-password": {
            "$ref": "#/components/schemas/netconf-node-topology_login-password"
          },
          "lock-datastore": {
            "description": "The operation allows the client to lock the entire configuration datastore\nsystem of a device.\nWARNING - With blocking the lock/unlock operations, the user is coming to operate\nin a manner which is not supported. Concurrent access to the data store may interfere\nwith data consistency.",
            "type": "boolean",
            "default": true,
            "example": true
          },
          "schema-cache-directory": {
            "description": "The destination schema repository for yang files relative to the cache directory.\nThis may be specified per netconf mount so that the loaded yang files are stored\nto a distinct directory to avoid potential conflict.",
            "type": "string",
            "default": "schema",
            "example": "Some schema-cache-directory"
          },
          "yang-library": {
            "$ref": "#/components/schemas/netconf-node-topology_yang-library"
          },
          "host": {
            "description": "",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "port": {
            "description": "",
            "type": "integer",
            "format": "int32",
            "example": 0
          },
          "tcp-only": {
            "description": "",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "protocol": {
            "$ref": "#/components/schemas/netconf-node-topology_protocol"
          },
          "schemaless": {
            "description": "",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "yang-module-capabilities": {
            "$ref": "#/components/schemas/netconf-node-topology_yang-module-capabilities"
          },
          "non-module-capabilities": {
            "$ref": "#/components/schemas/netconf-node-topology_non-module-capabilities"
          },
          "reconnect-on-changed-schema": {
            "description": "If true, the connector would auto disconnect/reconnect when schemas are changed in the\nremote device. The connector subscribes (right after connect) to base netconf notifications\nand listens for netconf-capability-change notification",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "connection-timeout-millis": {
            "description": "Specifies timeout in milliseconds after which connection must be established.",
            "type": "integer",
            "format": "int64",
            "default": 20000,
            "example": 0
          },
          "default-request-timeout-millis": {
            "description": "Timeout for blocking operations within transactions.",
            "type": "integer",
            "format": "int64",
            "default": 60000,
            "example": 0
          },
          "max-connection-attempts": {
            "description": "Maximum number of connection retries. Non positive value or null is interpreted as infinity.",
            "type": "string",
            "default": "0"
          },
          "min-backoff-millis": {
            "description": "Initial timeout in milliseconds to wait between connection attempts. Will be multiplied by\nbackoff-multiplier with every additional attempt",
            "type": "integer",
            "format": "int32",
            "default": 2000,
            "example": 0
          },
          "max-backoff-millis": {
            "description": "Maximum timeout in milliseconds to wait between connection attempts.",
            "type": "integer",
            "format": "int64",
            "default": 1800000,
            "example": 0
          },
          "backoff-multiplier": {
            "description": "Multiplier for backoff timeout. The backoff will be multiplied by this value with every\nadditional attempt.",
            "type": "number",
            "default": 1.5,
            "example": -922337203685477580.8
          },
          "backoff-jitter": {
            "description": "Range of backoff randomization. The backoff will be multiplied by a random number in the range\n(1 - backoff-jitter, 1 + backoff-jitter). Backoff-jitter must be in the range (0, 0.5).",
            "type": "string",
            "default": 0.1
          },
          "keepalive-delay": {
            "description": "Netconf connector sends keepalive RPCs while the session is idle, this delay specifies\nthe delay between keepalive RPC in seconds.\nIf a value <1 is provided, no keepalives will be sent",
            "type": "integer",
            "format": "int64",
            "default": 120,
            "example": 0
          },
          "concurrent-rpc-limit": {
            "description": "Limit of concurrent messages that can be send before reply messages are received.\nIf value <1 is provided, no limit will be enforced",
            "type": "string",
            "default": "0"
          },
          "actor-response-wait-time": {
            "description": "Time that slave actor will wait for response from master.",
            "type": "integer",
            "format": "int32",
            "default": 5,
            "example": 1
          },
          "odl-hello-message-capabilities": {
            "$ref": "#/components/schemas/netconf-node-topology_odl-hello-message-capabilities"
          },
          "ignore-missing-schema-sources": {
            "$ref": "#/components/schemas/netconf-node-topology_ignore-missing-schema-sources"
          },
          "node-id": {
            "description": "",
            "type": "string",
            "example": "Some node-id"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_login-password": {
        "title": "netconf-node-topology_login-password",
        "type": "object",
        "properties": {
          "password": {
            "description": "",
            "type": "string",
            "example": "Some password"
          },
          "username": {
            "description": "",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "login-password",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_yang-library": {
        "title": "netconf-node-topology_yang-library",
        "type": "object",
        "properties": {
          "password": {
            "description": "",
            "type": "string",
            "example": "Some password"
          },
          "yang-library-url": {
            "description": "Yang library to be plugged as additional source provider into the shared schema repository",
            "type": "string",
            "example": "Some yang-library-url"
          },
          "username": {
            "description": "",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "yang-library",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_protocol": {
        "title": "netconf-node-topology_protocol",
        "type": "object",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "enum": [
              "SSH",
              "TLS"
            ],
            "default": "SSH",
            "example": "SSH"
          },
          "tls": {
            "$ref": "#/components/schemas/netconf-node-topology_protocol_tls"
          }
        },
        "xml": {
          "name": "protocol",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_protocol_tls": {
        "title": "netconf-node-topology_protocol_tls",
        "type": "object",
        "properties": {
          "excluded-versions": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some excluded-versions"
            },
            "description": "A list of TLS version names provided in JDK that are not supported by the\ntarget netconf device, eg, the netopeer2 simulator does not support the\nSSLv2Hello. Most of the time, this list need not be set"
          }
        },
        "xml": {
          "name": "tls",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_yang-module-capabilities": {
        "title": "netconf-node-topology_yang-module-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Set a list of capabilities to override capabilities provided in device's hello message.\nCan be used for devices that do not report any yang modules in their hello message"
          },
          "override": {
            "description": "Whether to override or merge this list of capabilities with capabilities from device",
            "type": "boolean",
            "default": false,
            "example": true
          }
        },
        "xml": {
          "name": "yang-module-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_non-module-capabilities": {
        "title": "netconf-node-topology_non-module-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Set a list of non-module based capabilities to override or merge non-module capabilities\nprovided in device's hello message. Can be used for devices that do not report or\nincorrectly report non-module based capabilities in their hello message"
          },
          "override": {
            "description": "Whether to override or merge this list of non-module based capabilities with non-module\nbased capabilities from device",
            "type": "boolean",
            "default": false,
            "example": true
          }
        },
        "xml": {
          "name": "non-module-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_odl-hello-message-capabilities": {
        "title": "netconf-node-topology_odl-hello-message-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Certain devices are non-accepting of ODL's hello message.  This allows specification of\na custom ODL hello message based on a list of supported capabilities."
          }
        },
        "xml": {
          "name": "odl-hello-message-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_ignore-missing-schema-sources": {
        "title": "netconf-node-topology_ignore-missing-schema-sources",
        "type": "object",
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "properties": {
          "allowed": {
            "description": "Allows reconnection of the mount point. Default false.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "reconnect-time": {
            "description": "Time for reconnection - in units milliseconds. Default 5000 ms.",
            "type": "integer",
            "format": "int64",
            "default": 5000,
            "example": 0
          }
        },
        "xml": {
          "name": "ignore-missing-schema-sources",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "netconf-node-topology_delete-device_input": {
        "title": "netconf-node-topology_delete-device_input",
        "type": "object",
        "properties": {
          "node-id": {
            "description": "",
            "type": "string",
            "example": "Some node-id"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology": {
        "title": "network-topology_network-topology",
        "type": "object",
        "properties": {
          "topology": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology"
            },
            "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n"
          }
        },
        "xml": {
          "name": "network-topology",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology": {
        "title": "network-topology_network-topology_topology",
        "type": "object",
        "description": "\nThis is the model of an abstract topology.\nA topology contains nodes and links.\nEach topology MUST be identified by\nunique topology-id for reason that a network could contain many\ntopologies.\n",
        "properties": {
          "node": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node"
            },
            "description": "The list of network nodes defined for the topology."
          },
          "topology-types": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types"
          },
          "topology-id": {
            "description": "\nIt is presumed that a datastore will contain many topologies. To\ndistinguish between topologies it is vital to have UNIQUE\ntopology identifiers.\n",
            "type": "string",
            "example": "Some topology-id"
          },
          "link": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_link"
            },
            "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n"
          },
          "underlay-topology": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_underlay-topology"
            },
            "description": "Identifies the topology, or topologies, that this topology\nis dependent on."
          }
        },
        "xml": {
          "name": "topology",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_topology-types": {
        "title": "network-topology_network-topology_topology_topology-types",
        "type": "object",
        "description": "This container is used to identify the type, or types\n(as a topology can support several types simultaneously),\nof the topology.\nTopology types are the subject of several integrity constraints\nthat an implementing server can validate in order to\nmaintain integrity of the datastore.\nTopology types are indicated through separate data nodes;\nthe set of topology types is expected to increase over time.\nTo add support for a new topology, an augmenting module\nneeds to augment this container with a new empty optional\ncontainer to indicate the new topology type.\nThe use of a container allows to indicate a subcategorization\nof topology types.\nThe container SHALL NOT be augmented with any data nodes\nthat serve a purpose other than identifying a particular\ntopology type.\n",
        "properties": {
          "topology-netconf": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_topology-types_topology-netconf"
          }
        },
        "xml": {
          "name": "topology-types",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_topology-types_topology-netconf": {
        "title": "network-topology_network-topology_topology_topology-types_topology-netconf",
        "type": "object",
        "properties": {},
        "xml": {
          "name": "topology-netconf",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_underlay-topology": {
        "title": "network-topology_network-topology_topology_underlay-topology",
        "type": "object",
        "description": "Identifies the topology, or topologies, that this topology\nis dependent on.",
        "properties": {
          "topology-ref": {
            "description": "",
            "type": "string",
            "example": "Some topology-ref"
          }
        },
        "xml": {
          "name": "underlay-topology",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_node": {
        "title": "network-topology_network-topology_topology_node",
        "type": "object",
        "description": "The list of network nodes defined for the topology.",
        "properties": {
          "concurrent-rpc-limit": {
            "description": "Limit of concurrent messages that can be send before reply messages are received.\nIf value <1 is provided, no limit will be enforced",
            "type": "string",
            "default": "0",
            "xml": {
              "name": "concurrent-rpc-limit",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "node-id": {
            "description": "The identifier of a node in the topology.\nA node is specific to a topology to which it belongs.",
            "type": "string",
            "example": "Some node-id"
          },
          "min-backoff-millis": {
            "description": "Initial timeout in milliseconds to wait between connection attempts. Will be multiplied by\nbackoff-multiplier with every additional attempt",
            "type": "integer",
            "format": "int32",
            "default": 2000,
            "example": 0,
            "xml": {
              "name": "min-backoff-millis",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "login-password": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_login-password"
          },
          "tcp-only": {
            "description": "",
            "type": "boolean",
            "default": false,
            "example": true,
            "xml": {
              "name": "tcp-only",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "max-connection-attempts": {
            "description": "Maximum number of connection retries. Non positive value or null is interpreted as infinity.",
            "type": "string",
            "default": "0",
            "xml": {
              "name": "max-connection-attempts",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "reconnect-on-changed-schema": {
            "description": "If true, the connector would auto disconnect/reconnect when schemas are changed in the\nremote device. The connector subscribes (right after connect) to base netconf notifications\nand listens for netconf-capability-change notification",
            "type": "boolean",
            "default": false,
            "example": true,
            "xml": {
              "name": "reconnect-on-changed-schema",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "supporting-node": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node_supporting-node"
            },
            "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes."
          },
          "non-module-capabilities": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_non-module-capabilities"
          },
          "yang-module-capabilities": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-module-capabilities"
          },
          "lock-datastore": {
            "description": "The operation allows the client to lock the entire configuration datastore\nsystem of a device.\nWARNING - With blocking the lock/unlock operations, the user is coming to operate\nin a manner which is not supported. Concurrent access to the data store may interfere\nwith data consistency.",
            "type": "boolean",
            "default": true,
            "example": true,
            "xml": {
              "name": "lock-datastore",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "protocol": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol"
          },
          "ignore-missing-schema-sources": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_ignore-missing-schema-sources"
          },
          "backoff-multiplier": {
            "description": "Multiplier for backoff timeout. The backoff will be multiplied by this value with every\nadditional attempt.",
            "type": "number",
            "default": 1.5,
            "example": -922337203685477580.8,
            "xml": {
              "name": "backoff-multiplier",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "host": {
            "description": "",
            "type": "string",
            "example": "0.0.0.0",
            "minLength": 0,
            "maxLength": 2147483647,
            "xml": {
              "name": "host",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "yang-library": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_yang-library"
          },
          "odl-hello-message-capabilities": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_odl-hello-message-capabilities"
          },
          "max-backoff-millis": {
            "description": "Maximum timeout in milliseconds to wait between connection attempts.",
            "type": "integer",
            "format": "int64",
            "default": 1800000,
            "example": 0,
            "xml": {
              "name": "max-backoff-millis",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "keepalive-delay": {
            "description": "Netconf connector sends keepalive RPCs while the session is idle, this delay specifies\nthe delay between keepalive RPC in seconds.\nIf a value <1 is provided, no keepalives will be sent",
            "type": "integer",
            "format": "int64",
            "default": 120,
            "example": 0,
            "xml": {
              "name": "keepalive-delay",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "termination-point": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node_termination-point"
            },
            "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface."
          },
          "backoff-jitter": {
            "description": "Range of backoff randomization. The backoff will be multiplied by a random number in the range\n(1 - backoff-jitter, 1 + backoff-jitter). Backoff-jitter must be in the range (0, 0.5).",
            "type": "string",
            "default": 0.1,
            "xml": {
              "name": "backoff-jitter",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "schemaless": {
            "description": "",
            "type": "boolean",
            "default": false,
            "example": true,
            "xml": {
              "name": "schemaless",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "port": {
            "description": "",
            "type": "integer",
            "format": "int32",
            "example": 0,
            "xml": {
              "name": "port",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "connection-timeout-millis": {
            "description": "Specifies timeout in milliseconds after which connection must be established.",
            "type": "integer",
            "format": "int64",
            "default": 20000,
            "example": 0,
            "xml": {
              "name": "connection-timeout-millis",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "default-request-timeout-millis": {
            "description": "Timeout for blocking operations within transactions.",
            "type": "integer",
            "format": "int64",
            "default": 60000,
            "example": 0,
            "xml": {
              "name": "default-request-timeout-millis",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "schema-cache-directory": {
            "description": "The destination schema repository for yang files relative to the cache directory.\nThis may be specified per netconf mount so that the loaded yang files are stored\nto a distinct directory to avoid potential conflict.",
            "type": "string",
            "default": "schema",
            "example": "Some schema-cache-directory",
            "xml": {
              "name": "schema-cache-directory",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "actor-response-wait-time": {
            "description": "Time that slave actor will wait for response from master.",
            "type": "integer",
            "format": "int32",
            "default": 5,
            "example": 1,
            "xml": {
              "name": "actor-response-wait-time",
              "namespace": "urn:opendaylight:netconf-node-topology"
            }
          },
          "pass-through": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_pass-through"
          }
        },
        "xml": {
          "name": "node",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_node_supporting-node": {
        "title": "network-topology_network-topology_topology_node_supporting-node",
        "type": "object",
        "description": "This list defines vertical layering information for nodes.\nIt allows to capture for any given node, which node (or nodes)\nin the corresponding underlay topology it maps onto.\nA node can map to zero, one, or more nodes below it;\naccordingly there can be zero, one, or more elements in the list.\nIf there are specific layering requirements, for example\nspecific to a particular type of topology that only allows\nfor certain layering relationships, the choice\nbelow can be augmented with additional cases.\nA list has been chosen rather than a leaf-list in order\nto provide room for augmentations, e.g. for\nstatistics or priorization information associated with\nsupporting nodes.",
        "properties": {
          "node-ref": {
            "description": "",
            "type": "string",
            "example": "Some node-ref"
          },
          "topology-ref": {
            "description": "",
            "type": "string",
            "example": "Some topology-ref"
          }
        },
        "xml": {
          "name": "supporting-node",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_node_termination-point": {
        "title": "network-topology_network-topology_topology_node_termination-point",
        "type": "object",
        "description": "A termination point can terminate a link.\nDepending on the type of topology, a termination point could,\nfor example, refer to a port or an interface.",
        "properties": {
          "tp-id": {
            "description": "",
            "type": "string",
            "example": "Some tp-id"
          }
        },
        "xml": {
          "name": "termination-point",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_node_ignore-missing-schema-sources": {
        "title": "network-topology_network-topology_topology_node_ignore-missing-schema-sources",
        "type": "object",
        "description": "Allows mount point to reconnect on the 'missing schema sources' error.\nWARNING - enabling the reconnection on the 'missing schema sources' error can lead\nto unexpected errors at runtime.",
        "properties": {
          "allowed": {
            "description": "Allows reconnection of the mount point. Default false.",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "reconnect-time": {
            "description": "Time for reconnection - in units milliseconds. Default 5000 ms.",
            "type": "integer",
            "format": "int64",
            "default": 5000,
            "example": 0
          }
        },
        "xml": {
          "name": "ignore-missing-schema-sources",
          "namespace": "urn:opendaylight:netconf-node-optional"
        }
      },
      "network-topology_network-topology_topology_node_login-password": {
        "title": "network-topology_network-topology_topology_node_login-password",
        "type": "object",
        "properties": {
          "password": {
            "description": "",
            "type": "string",
            "format": "byte"
          },
          "username": {
            "description": "",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "login-password",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_clustered-connection-status": {
        "title": "network-topology_network-topology_topology_node_clustered-connection-status",
        "type": "object",
        "properties": {
          "node-status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node_clustered-connection-status_node-status"
            },
            "description": ""
          },
          "netconf-master-node": {
            "description": "",
            "type": "string",
            "example": "Some netconf-master-node"
          }
        },
        "xml": {
          "name": "clustered-connection-status",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_clustered-connection-status_node-status": {
        "title": "network-topology_network-topology_topology_node_clustered-connection-status_node-status",
        "type": "object",
        "properties": {
          "node": {
            "description": "",
            "type": "string",
            "example": "Some node"
          },
          "status": {
            "description": "",
            "type": "string",
            "enum": [
              "connected",
              "unavailable",
              "failed"
            ],
            "example": "connected"
          }
        },
        "xml": {
          "name": "node-status",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_available-capabilities": {
        "title": "network-topology_network-topology_topology_node_available-capabilities",
        "type": "object",
        "properties": {
          "available-capability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node_available-capabilities_available-capability"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "available-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_available-capabilities_available-capability": {
        "title": "network-topology_network-topology_topology_node_available-capabilities_available-capability",
        "type": "object",
        "properties": {
          "capability": {
            "description": "",
            "type": "string",
            "example": "Some capability"
          },
          "capability-origin": {
            "description": "",
            "type": "string",
            "enum": [
              "user-defined",
              "device-advertised"
            ],
            "example": "user-defined"
          }
        },
        "xml": {
          "name": "available-capability",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_unavailable-capabilities": {
        "title": "network-topology_network-topology_topology_node_unavailable-capabilities",
        "type": "object",
        "properties": {
          "unavailable-capability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_node_unavailable-capabilities_unavailable-capability"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "unavailable-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_unavailable-capabilities_unavailable-capability": {
        "title": "network-topology_network-topology_topology_node_unavailable-capabilities_unavailable-capability",
        "type": "object",
        "properties": {
          "capability": {
            "description": "",
            "type": "string",
            "example": "Some capability"
          },
          "failure-reason": {
            "description": "",
            "type": "string",
            "enum": [
              "missing-source",
              "unable-to-resolve"
            ],
            "example": "missing-source"
          }
        },
        "xml": {
          "name": "unavailable-capability",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_pass-through": {
        "title": "network-topology_network-topology_topology_node_pass-through",
        "type": "object",
        "description": "When the underlying node is connected, its NETCONF context\nis available verbatim under this container through the\nmount extension.",
        "properties": {},
        "xml": {
          "name": "pass-through",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_yang-library": {
        "title": "network-topology_network-topology_topology_node_yang-library",
        "type": "object",
        "properties": {
          "password": {
            "description": "",
            "type": "string",
            "example": "Some password"
          },
          "yang-library-url": {
            "description": "Yang library to be plugged as additional source provider into the shared schema repository",
            "type": "string",
            "example": "Some yang-library-url"
          },
          "username": {
            "description": "",
            "type": "string",
            "example": "Some username"
          }
        },
        "xml": {
          "name": "yang-library",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_protocol": {
        "title": "network-topology_network-topology_topology_node_protocol",
        "type": "object",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "enum": [
              "SSH",
              "TLS"
            ],
            "default": "SSH",
            "example": "SSH"
          },
          "tls": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_node_protocol_tls"
          }
        },
        "xml": {
          "name": "protocol",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_protocol_tls": {
        "title": "network-topology_network-topology_topology_node_protocol_tls",
        "type": "object",
        "properties": {
          "excluded-versions": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some excluded-versions"
            },
            "description": "A list of TLS version names provided in JDK that are not supported by the\ntarget netconf device, eg, the netopeer2 simulator does not support the\nSSLv2Hello. Most of the time, this list need not be set"
          }
        },
        "xml": {
          "name": "tls",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_yang-module-capabilities": {
        "title": "network-topology_network-topology_topology_node_yang-module-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Set a list of capabilities to override capabilities provided in device's hello message.\nCan be used for devices that do not report any yang modules in their hello message"
          },
          "override": {
            "description": "Whether to override or merge this list of capabilities with capabilities from device",
            "type": "boolean",
            "default": false,
            "example": true
          }
        },
        "xml": {
          "name": "yang-module-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_non-module-capabilities": {
        "title": "network-topology_network-topology_topology_node_non-module-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Set a list of non-module based capabilities to override or merge non-module capabilities\nprovided in device's hello message. Can be used for devices that do not report or\nincorrectly report non-module based capabilities in their hello message"
          },
          "override": {
            "description": "Whether to override or merge this list of non-module based capabilities with non-module\nbased capabilities from device",
            "type": "boolean",
            "default": false,
            "example": true
          }
        },
        "xml": {
          "name": "non-module-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_node_odl-hello-message-capabilities": {
        "title": "network-topology_network-topology_topology_node_odl-hello-message-capabilities",
        "type": "object",
        "properties": {
          "capability": {
            "type": "array",
            "items": {
              "type": "string",
              "example": "Some capability"
            },
            "description": "Certain devices are non-accepting of ODL's hello message.  This allows specification of\na custom ODL hello message based on a list of supported capabilities."
          }
        },
        "xml": {
          "name": "odl-hello-message-capabilities",
          "namespace": "urn:opendaylight:netconf-node-topology"
        }
      },
      "network-topology_network-topology_topology_link": {
        "title": "network-topology_network-topology_topology_link",
        "type": "object",
        "description": "\nA Network Link connects a by Local (Source) node and\na Remote (Destination) Network Nodes via a set of the\nnodes' termination points.\nAs it is possible to have several links between the same\nsource and destination nodes, and as a link could potentially\nbe re-homed between termination points, to ensure that we\nwould always know to distinguish between links, every link\nis identified by a dedicated link identifier.\nNote that a link models a point-to-point link, not a multipoint\nlink.\nLayering dependencies on links in underlay topologies are\nnot represented as the layering information of nodes and of\ntermination points is sufficient.\n",
        "properties": {
          "link-id": {
            "description": "The identifier of a link in the topology.\nA link is specific to a topology to which it belongs.",
            "type": "string",
            "example": "Some link-id"
          },
          "supporting-link": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/network-topology_network-topology_topology_link_supporting-link"
            },
            "description": ""
          },
          "destination": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_link_destination"
          },
          "source": {
            "$ref": "#/components/schemas/network-topology_network-topology_topology_link_source"
          }
        },
        "required": [
          "destination",
          "source"
        ],
        "xml": {
          "name": "link",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_link_source": {
        "title": "network-topology_network-topology_topology_link_source",
        "type": "object",
        "properties": {
          "source-node": {
            "description": "Source node identifier, must be in same topology.",
            "type": "string",
            "example": "Some source-node"
          },
          "source-tp": {
            "description": "Termination point within source node that terminates the link.",
            "type": "string",
            "example": "Some source-tp"
          }
        },
        "required": [
          "source-node"
        ],
        "xml": {
          "name": "source",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_link_destination": {
        "title": "network-topology_network-topology_topology_link_destination",
        "type": "object",
        "properties": {
          "dest-node": {
            "description": "Destination node identifier, must be in same topology.",
            "type": "string",
            "example": "Some dest-node"
          },
          "dest-tp": {
            "description": "Termination point within destination node that terminates the link.",
            "type": "string",
            "example": "Some dest-tp"
          }
        },
        "required": [
          "dest-node"
        ],
        "xml": {
          "name": "destination",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "network-topology_network-topology_topology_link_supporting-link": {
        "title": "network-topology_network-topology_topology_link_supporting-link",
        "type": "object",
        "properties": {
          "link-ref": {
            "description": "",
            "type": "string",
            "example": "Some link-ref"
          }
        },
        "xml": {
          "name": "supporting-link",
          "namespace": "urn:TBD:params:xml:ns:yang:network-topology"
        }
      },
      "notifications_create-subscription_input": {
        "title": "notifications_create-subscription_input",
        "type": "object",
        "properties": {
          "stream": {
            "description": "An optional parameter that indicates which stream of events\nis of interest. If not present, then events in the default\nNETCONF stream will be sent.",
            "type": "string",
            "default": "NETCONF",
            "example": "Some stream"
          },
          "filter": {
            "description": "An optional parameter that indicates which subset of all\npossible events is of interest. The format of this\nparameter is the same as that of the filter parameter\nin the NETCONF protocol operations. If not present,\nall events not precluded by other parameters will\nbe sent.",
            "example": "<filter> ... </filter>",
            "type": "string"
          },
          "startTime": {
            "description": "A parameter used to trigger the replay feature and\nindicates that the replay should start at the time\nspecified. If start time is not present, this is not a\nreplay subscription.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          },
          "stopTime": {
            "description": "An optional parameter used with the optional replay\nfeature to indicate the newest notifications of\ninterest. If stop time is not present, the notifications\nwill continue until the subscription is terminated.\nMust be used with startTime.",
            "type": "string",
            "example": "0000-00-00T00:00:00Z",
            "minLength": 0,
            "maxLength": 2147483647
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:ietf:params:xml:ns:netconf:notification:1.0"
        }
      },
      "odl-device-notification_subscribe-device-notification_input": {
        "title": "odl-device-notification_subscribe-device-notification_input",
        "type": "object",
        "properties": {
          "path": {
            "description": "Device mount point path",
            "type": "string"
          }
        },
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:device:notification"
        }
      },
      "odl-device-notification_subscribe-device-notification_output": {
        "title": "odl-device-notification_subscribe-device-notification_output",
        "type": "object",
        "properties": {
          "stream-name": {
            "description": "Notification stream name.",
            "type": "string",
            "example": "Some stream-name"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:device:notification"
        }
      },
      "odl-entity-owners_get-entities_output": {
        "title": "odl-entity-owners_get-entities_output",
        "type": "object",
        "properties": {
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/odl-entity-owners_entities"
            },
            "description": ""
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-entity-owners_entities": {
        "title": "odl-entity-owners_entities",
        "type": "object",
        "properties": {
          "name": {
            "description": "",
            "type": "string"
          },
          "owner-node": {
            "description": "",
            "type": "string",
            "example": "Some owner-node",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "type": {
            "description": "",
            "type": "string",
            "example": "Some type",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "candidate-nodes": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string",
              "example": "Some candidate-nodes",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "",
            "example": [
              "Some candidate-nodes"
            ]
          }
        },
        "required": [
          "name",
          "type",
          "candidate-nodes"
        ],
        "xml": {
          "name": "entities",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-entity-owners_get-entity_input": {
        "title": "odl-entity-owners_get-entity_input",
        "type": "object",
        "properties": {
          "type": {
            "description": "",
            "type": "string",
            "example": "Some type",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "name": {
            "description": "",
            "type": "string"
          }
        },
        "required": [
          "type",
          "name"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-entity-owners_get-entity_output": {
        "title": "odl-entity-owners_get-entity_output",
        "type": "object",
        "properties": {
          "owner-node": {
            "description": "",
            "type": "string",
            "example": "Some owner-node",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "candidate-nodes": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string",
              "example": "Some candidate-nodes",
              "minLength": 1,
              "maxLength": 2147483647
            },
            "description": "",
            "example": [
              "Some candidate-nodes"
            ]
          }
        },
        "required": [
          "candidate-nodes"
        ],
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-entity-owners_get-entity-owner_input": {
        "title": "odl-entity-owners_get-entity-owner_input",
        "type": "object",
        "properties": {
          "type": {
            "description": "",
            "type": "string",
            "example": "Some type",
            "minLength": 1,
            "maxLength": 2147483647
          },
          "name": {
            "description": "",
            "type": "string"
          }
        },
        "required": [
          "type",
          "name"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-entity-owners_get-entity-owner_output": {
        "title": "odl-entity-owners_get-entity-owner_output",
        "type": "object",
        "properties": {
          "owner-node": {
            "description": "",
            "type": "string",
            "example": "Some owner-node",
            "minLength": 1,
            "maxLength": 2147483647
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:entity-owners"
        }
      },
      "odl-general-entity_entity": {
        "title": "odl-general-entity_entity",
        "type": "object",
        "properties": {
          "name": {
            "description": "",
            "type": "string",
            "example": "Some name"
          }
        },
        "xml": {
          "name": "entity",
          "namespace": "urn:opendaylight:params:xml:ns:yang:mdsal:core:general-entity"
        }
      },
      "sal-remote_create-data-change-event-subscription_input": {
        "title": "sal-remote_create-data-change-event-subscription_input",
        "type": "object",
        "properties": {
          "path": {
            "description": "Subtree path. ",
            "type": "string"
          },
          "datastore": {
            "description": "",
            "type": "string",
            "enum": [
              "OPERATIONAL",
              "CONFIGURATION"
            ],
            "default": "CONFIGURATION",
            "example": "OPERATIONAL",
            "xml": {
              "name": "datastore",
              "namespace": "urn:sal:restconf:event:subscription"
            }
          },
          "scope": {
            "description": "",
            "type": "string",
            "enum": [
              "BASE",
              "ONE",
              "SUBTREE"
            ],
            "example": "BASE",
            "xml": {
              "name": "scope",
              "namespace": "urn:sal:restconf:event:subscription"
            }
          },
          "notification-output-type": {
            "description": "Input parameter which type of output will be parsed on notification",
            "type": "string",
            "enum": [
              "JSON",
              "XML"
            ],
            "default": "XML",
            "example": "JSON",
            "xml": {
              "name": "notification-output-type",
              "namespace": "urn:sal:restconf:event:subscription"
            }
          }
        },
        "required": [
          "path"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
        }
      },
      "sal-remote_create-data-change-event-subscription_output": {
        "title": "sal-remote_create-data-change-event-subscription_output",
        "type": "object",
        "properties": {
          "stream-name": {
            "description": "Notification stream name.",
            "type": "string",
            "example": "Some stream-name"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
        }
      },
      "sal-remote_create-notification-stream_input": {
        "title": "sal-remote_create-notification-stream_input",
        "type": "object",
        "properties": {
          "notifications": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "string",
              "example": "Some notifications"
            },
            "description": "Notification QNames",
            "example": [
              "Some notifications"
            ]
          },
          "notification-output-type": {
            "description": "Input parameter which type of output will be parsed on notification",
            "type": "string",
            "enum": [
              "JSON",
              "XML"
            ],
            "default": "XML",
            "example": "JSON",
            "xml": {
              "name": "notification-output-type",
              "namespace": "urn:sal:restconf:event:subscription"
            }
          }
        },
        "required": [
          "notifications"
        ],
        "xml": {
          "name": "input",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
        }
      },
      "sal-remote_create-notification-stream_output": {
        "title": "sal-remote_create-notification-stream_output",
        "type": "object",
        "properties": {
          "notification-stream-identifier": {
            "description": "Unique notification stream identifier, in which notifications will be propagated",
            "type": "string",
            "example": "Some notification-stream-identifier"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
        }
      },
      "sal-remote_begin-transaction_output": {
        "title": "sal-remote_begin-transaction_output",
        "type": "object",
        "properties": {
          "data-modification-transaction": {
            "description": "DataModificationTransaction xml",
            "example": "<data-modification-transaction> ... </data-modification-transaction>",
            "type": "string"
          }
        },
        "xml": {
          "name": "output",
          "namespace": "urn:opendaylight:params:xml:ns:yang:controller:md:sal:remote"
        }
      },
      "subscribe-to-notification_notifi": {
        "title": "subscribe-to-notification_notifi",
        "type": "object",
        "properties": {
          "location": {
            "description": "",
            "type": "string",
            "example": "Some location"
          }
        },
        "xml": {
          "name": "notifi",
          "namespace": "subscribe:to:notification"
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "scheme": "basic",
        "type": "http"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ]
}