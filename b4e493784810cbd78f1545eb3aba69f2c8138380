{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0f79a28f_bdcd6bac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 7231
      },
      "writtenOn": "2023-06-21T08:53:29Z",
      "side": 1,
      "message": "Just tested this PR. I confirmed that JIRA NETCONF-1051 is resolved on my testbed.\n\nThanks a lot\n\nOlivier",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f54cc1b7_c3d109eb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 8144
      },
      "writtenOn": "2023-06-21T11:13:37Z",
      "side": 1,
      "message": "Can you please check tests at https://github.com/search?q\u003drepo%3Aopendaylight%2Fnetconf%20notifi_list_Test\u0026type\u003dcode?\n\nI wonder why existing tests did not catch the issue, maybe this patch deserves one more additional.",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "adc448d7_fbcebf8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1927
      },
      "writtenOn": "2023-06-22T04:26:16Z",
      "side": 1,
      "message": "This is for data change notifications, so ListenerAdapterTest seems to be the right place. Please take a look at the new test cases for list entry.",
      "parentUuid": "f54cc1b7_c3d109eb",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8026b5ec_7b376719",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 8144
      },
      "writtenOn": "2023-06-21T11:13:37Z",
      "side": 1,
      "message": "Have you tries to subscribe to unkeyed lists, too?\nIt means here we get UnkeyedListEntryNode.",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134378b5_c516ebe0",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1927
      },
      "writtenOn": "2023-06-22T04:26:16Z",
      "side": 1,
      "message": "Is it possible to target a specific entry in an unkeyed list?\nSince the type of \u0027path\u0027 in \u0027sal-remote:create-data-change-event-subscription\u0027 is instance-identifier, I guess it is possible to use a path targeting an entry in unkeyed list in theory. But it doesn\u0027t look like it\u0027s actually supported.",
      "parentUuid": "8026b5ec_7b376719",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61838cc8_a728f0d5",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 649
      },
      "writtenOn": "2023-06-22T20:57:55Z",
      "side": 1,
      "message": "Not exactly sure, but it should work via https://www.javadoc.io/doc/org.opendaylight.yangtools/yangtools-docs/latest/org/opendaylight/yangtools/yang/data/codec/xml/XMLStreamNormalizedNodeStreamWriter.html, which takes a YangInstanceIdentifier and hence should do The Right Thing(tm).\n\nThe way I would guess it should work is that either:\n- we specify parent list and then emit the entry, or\n- we specify the entry itself",
      "parentUuid": "134378b5_c516ebe0",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b001d359_3cdf0b32",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 649
      },
      "writtenOn": "2023-06-22T21:00:40Z",
      "side": 1,
      "message": "https://www.javadoc.io/doc/org.opendaylight.yangtools/yangtools-docs/latest/org/opendaylight/yangtools/yang/data/codec/xml/XMLStreamNormalizedNodeStreamWriter.html#create(javax.xml.stream.XMLStreamWriter,org.opendaylight.yangtools.yang.model.api.EffectiveModelContext,org.opendaylight.yangtools.yang.data.api.YangInstanceIdentifier)\n\nis the proper link. The thing with these methods: you really need to uses the closest thing to yang-data-api, but there are other (legacy or weird) avenues.",
      "parentUuid": "61838cc8_a728f0d5",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9421a210_47c6a421",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1927
      },
      "writtenOn": "2023-06-23T20:04:44Z",
      "side": 1,
      "message": "I added the following unkeyed list to netconf-node-topoloyg.yang as a hackish way to do some testing:\n```\n    list nokey {\n        ordered-by user;\n        leaf name {\n            type string;\n        }\n    }\n```\nAnd when the first entry of the list is targeted like this:\n```\n{\n    \"input\": {\n        \"path\": \"/network-topology:network-topology/topology[topology-id\u003d\u0027topology-netconf\u0027]/node[node-id\u003d\u0027ncserver\u0027]/netconf-node-topology:nokey[1]\",\n        \"sal-remote-augment:datastore\": \"CONFIGURATION\",\n        \"sal-remote-augment:scope\": \"SUBTREE\",\n        \"sal-remote-augment:notification-output-type\": \"JSON\"\n    }\n}\n```\nI get this error:\n```\n2023-06-23T17:22:21,454 | DEBUG | qtp1627992198-206 | JsonNormalizedNodeBodyReader     | 264 - org.opendaylight.netconf.restconf-nb - 6.0.0.SNAPSHOT | Error parsing json input\njava.lang.IllegalArgumentException: Could not parse Instance Identifier \u0027/network-topology:network-topology/topology[topology-id\u003d\u0027topology-netconf\u0027]/node[node-id\u003d\u0027ncserver\u0027]/netconf-node-topology:nokey[1]\u0027. Offset: 128 : Reason: Entry (urn:opendaylight:netconf-node-topology?revision\u003d2022-12-25)nokey does not allow specifying predicates.\n\tat org.opendaylight.yangtools.yang.data.util.XpathStringParsingPathArgumentBuilder.iae(XpathStringParsingPathArgumentBuilder.java:261) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.util.XpathStringParsingPathArgumentBuilder.computeIdentifierWithPredicate(XpathStringParsingPathArgumentBuilder.java:149) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.util.XpathStringParsingPathArgumentBuilder.computeNextArgument(XpathStringParsingPathArgumentBuilder.java:113) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.util.XpathStringParsingPathArgumentBuilder.build(XpathStringParsingPathArgumentBuilder.java:96) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.util.AbstractStringInstanceIdentifierCodec.deserializeImpl(AbstractStringInstanceIdentifierCodec.java:165) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.util.AbstractStringInstanceIdentifierCodec.deserializeImpl(AbstractStringInstanceIdentifierCodec.java:35) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.api.codec.AbstractIllegalArgumentCodec.deserialize(AbstractIllegalArgumentCodec.java:27) ~[?:?]\n\tat org.opendaylight.yangtools.yang.data.codec.gson.JSONInstanceIdentifierCodec.parseValue(JSONInstanceIdentifierCodec.java:102) ~[bundleFile:?]\n\tat org.opendaylight.yangtools.yang.data.codec.gson.JSONInstanceIdentifierCodec$RFC7951.parseValue(JSONInstanceIdentifierCodec.java:37) ~[bundleFile:?]\n```\nSo looks like it is not allowed/supported to specify an entry for a list without keys.\n\nWhen the list itself is targeted with the following path:\n```\n\"path\": \"/network-topology:network-topology/topology[topology-id\u003d\u0027topology-netconf\u0027]/node[node-id\u003d\u0027ncserver\u0027]/netconf-node-topology:nokey\"\n```\n\nthe subscription is successfully created and data change request is registered but no data change notification is received when the list is updated, either changing a leaf in a list entry or adding/removing an entry.\n\nSo it appears that there are multiple issues blocking support of unkeyed lists.",
      "parentUuid": "b001d359_3cdf0b32",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5799341b_b3459fb9",
        "filename": "restconf/restconf-nb/src/main/java/org/opendaylight/restconf/nb/rfc8040/streams/listeners/AbstractWebsocketSerializer.java",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 649
      },
      "writtenOn": "2023-07-05T18:39:35Z",
      "side": 1,
      "message": "Yeah, there is a major difference between keyed/unkeyed lists. Unkeyed lists are similar to leaf-lists in terms of yang-data-api -- i.e. they are pretty much atomic in terms of changes. NodeIdentifierWithPredicates is only applicable to keyed lists -- and then they are a bit of black magic w.r.t. how exactly they work internally.\n\nAt the end of the day, this boils down to accidental features and their clean up -- YangInstanceIdentifier is meant to mirror exactly RFC7950 semantics, but it gets overloaded to act as a substitute to RFC6241 filters in some contexts. The above failure trace is indicative of such misuse -- a RFC7950 instance-identifier is not a filter, but rather a exact identifier and therefore that codepath cannot not be used to create a YangInstanceIdentifier meant to work as a filter -- which might be appropriate to select unkeyed list entries.\n\nAt some point (yangtools-12/mdsal-13 provided we get the funding) we will make a strong distinction between the two, so that the APIs express exact semantics -- and all users will need to be updated to differentiate between the two.",
      "parentUuid": "9421a210_47c6a421",
      "revId": "b4e493784810cbd78f1545eb3aba69f2c8138380",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}