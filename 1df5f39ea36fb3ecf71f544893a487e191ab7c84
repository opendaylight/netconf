{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ece1823a_428a49af",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-30T10:26:41Z",
      "side": 1,
      "message": "Rather investigate usage of `SchemaTreeInference` in List as stack is something mutable?",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b635f3e_ac59657a",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-30T10:35:28Z",
      "side": 1,
      "message": "Ideally, can we remove this list? Why is not enough list of QNames?",
      "parentUuid": "ece1823a_428a49af",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95ae0334_35c0db9a",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-04-30T12:37:19Z",
      "side": 1,
      "message": "This is list for one reason only - wildcards. So we have 2 cases:\n1. Exact filter - there will be always only 1 element in this list that will represent exact path - easy.\n2. Wildcard filter (full wildcard or partial doesn\u0027t matter) - here we need this list. Lets say there is this filter:\n  \u003cstream-subtree-filter\u003e\n    \u003ctoasterRestocked xmlns\u003d\"\"\u003e\n      \u003camount/\u003e\n    \u003c/toasterRestocked\u003e\n  \u003c/stream-subtree-filter\u003e\n\nWhen you look into schema you won\u0027t necessarily find \"toasterRestocked\" inside only one model. It can be present in two, three or more models, it can be augmented and so on. At this point we only have local name so there is no way to determine which one to use. Because of that every possible \"toasterRestocked\" from every model should be saved. Let say we had two this time: namespace1_toasterRestocked and namespace2_toasterRestocked now saved into wildcard. The children will have 2 stacks respectively. When got to \"amount\" then we will try look for it under each path: namespace1_toasterRestocked and namespace2_toasterRestocked and record and do things with them. So I need to know parentStack to then for each and try find child. Also parent can be choice - in that case I should make 2 steps - in case and in child. That\u0027s why only QName is not enough.",
      "parentUuid": "3b635f3e_ac59657a",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "888ed566_a5ec91c7",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-30T12:41:06Z",
      "side": 1,
      "message": "QName contains all: local name, revision and namespace",
      "parentUuid": "95ae0334_35c0db9a",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb8ce2ba_cd400f28",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-04-30T13:38:31Z",
      "side": 1,
      "message": "Yes but it is probably naming issue. This \"children\" is list of paths where we will be searching for children on the next step of recursion. Name is misleading - it rather should be called \"pathsToElementSchema\" - i.e. list that contains possible paths(or only one path in case with exact node) that are leading to current element we processing in schema tree. If current element has children then on next iteration have any children - then this list will be used to search for them.",
      "parentUuid": "888ed566_a5ec91c7",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d1a0158_2f2380e0",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-04-30T13:44:00Z",
      "side": 1,
      "message": "Seme for \"childrenQNames\" - elementQNames",
      "parentUuid": "fb8ce2ba_cd400f28",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "937e87c7_d8674589",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-04-30T13:54:13Z",
      "side": 1,
      "message": "And QName contains all that - you right. But I can\u0027t take QName and find node in EffectiveModelContxt - it should be path and Qname. Path is coming from \"parents\" parameter and QName is created below depending on exact/wildcard. Then \"childrenQNames\" is something that is later used to create NamespaceSelection for SubtreeFilter. And \"children\" is new path that used in recursion if current element has children.",
      "parentUuid": "8d1a0158_2f2380e0",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d46f7ff_5fdf53ba",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-02T05:55:26Z",
      "side": 1,
      "message": "I would expect that stack is there be to used to find child(ren) as we wish.",
      "parentUuid": "937e87c7_d8674589",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c4bcf0e_b7e0f56d",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T08:09:02Z",
      "side": 1,
      "message": "Yes it is precisely what it used for. Each stack in the list is used to find child(ren) under parent. Because of wildcard there can be multiple parents. So I have to search under each. And for that I am storing path to each parent in \"parents\" list. This \"children\" list will become \"parents\" list when we get to line 223 - on next iteration of the recursion.\nEach iteration of this method is searching for child(ren) under every parent. I can\u0027t make it branch every time when there are multiple parent/child nodes in schema. Reason for that is we can go through XMLStreamReader events only one time. Because of that List\u003cSchemaInferenceStack\u003e.",
      "parentUuid": "8d46f7ff_5fdf53ba",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fddc2fa3_abe1c456",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-02T08:31:43Z",
      "side": 1,
      "message": "How many stack we have for one data?",
      "parentUuid": "9c4bcf0e_b7e0f56d",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0429e461_90ec4fd6",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T09:58:42Z",
      "side": 1,
      "message": "If filter is exact all the way (means there is namespace for every element) - one stack in this list on every iteration.\nIf wildcard is present - then there will be as many as matching nodes in schema context(matching by local name).\nUsing same example that I mentioned above it will be like this:\n1) At start - one empty stack\n2) On first iteration search will find two toasterRestocked in context - list will have two stacks: one \"/namespace1_toasterRestocked\" and second one \"/namespace2_toasterRestocked\"\n3) On second iteration search will look for \"amount\" under \"/namespace1_toasterRestocked\" and \"/namespace2_toasterRestocked\" - how many nodes was found - that many paths will be. Those then will be used on next iteration.\nOf course in this case they won\u0027t matter because \"amount\" does not have children in filter. Method will just return SelectionNode at that point.",
      "parentUuid": "fddc2fa3_abe1c456",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "616622cd_2d6b4c3d",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T10:22:45Z",
      "side": 1,
      "message": "IMO I\u0027m pretty sure at exact part of this logic.\nIf thinking about improvements then maybe something can be done to wildcard - adding some logic when going back up from recursion to reject some of the wildcards if they does not match xml filter seems reasonable too me. Now reader searching for every matching node but doesn\u0027t account for what goes after that. So adding some conditions may make filter smaller. This is something that borderlines with Matcher so I only considered it and didn\u0027t implement. BUT it is not something that should affect Matcher or matching notification what should be rejected should work with this current implementation. It will in theory reduce number of checks by small amount that Matcher do for some types of wildcards filters and that\u0027s pretty much it.",
      "parentUuid": "0429e461_90ec4fd6",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3db84631_b929768d",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-02T13:14:45Z",
      "side": 1,
      "message": "The diff in processing exact and wildcard is that:\n- for exact you search for module in context\n- for wildcard you iterate over all modules",
      "parentUuid": "616622cd_2d6b4c3d",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a53ebc6_79e54b50",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T14:12:56Z",
      "side": 1,
      "message": "Pretty much yes.\n - exact - check if there is a module with given namespace. If yes - take module QName and based on it and element name creates proper QName with name, namespace and revision. Then use that QName to enterChild in stack.\n - wildcard - does same but for every module.",
      "parentUuid": "3db84631_b929768d",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ddb24ff_3cd8b49e",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 109,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T07:25:22Z",
      "side": 1,
      "message": "Resolved in https://git.opendaylight.org/gerrit/c/netconf/+/116471",
      "parentUuid": "5a53ebc6_79e54b50",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11615c40_87492643",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 151,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T08:20:09Z",
      "side": 1,
      "message": "what are you breaking here?",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c0df046_5edeefe4",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 151,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T08:32:38Z",
      "side": 1,
      "message": "I think it is line 113. Because at this point node was found so checking other parents does not make sense.\nYes this part is looking for Exact node but this does not means parent node also Exact - it may be wildcard - in that case there may be two or more parent stacks",
      "parentUuid": "11615c40_87492643",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f64b27d8_9fcb5238",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 151,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T08:47:39Z",
      "side": 1,
      "message": "no, here, there is nothing to break, it just if, not while",
      "parentUuid": "0c0df046_5edeefe4",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41eb0824_ee51162a",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 151,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T10:15:12Z",
      "side": 1,
      "message": "M? I meant \"for\" that starts on line 113. This break means that we found exact node under current parent and don\u0027t need to check other parents so break",
      "parentUuid": "f64b27d8_9fcb5238",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29de43c5_84596ef0",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 155,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T08:39:54Z",
      "side": 1,
      "message": "This one is unnecessary - line 153 is enough.",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edb771ee_b00267c4",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 155,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T08:47:39Z",
      "side": 1,
      "message": "lol, I have already fixed it: https://git.opendaylight.org/gerrit/c/netconf/+/116469/3/protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
      "parentUuid": "29de43c5_84596ef0",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f9e6e34_889004d4",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 155,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T10:15:22Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "edb771ee_b00267c4",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09861925_86e6fab1",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 193,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-02T12:21:46Z",
      "side": 1,
      "message": "this fails is parentStack is empty",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e70940d7_3faf0811",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 193,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T14:12:56Z",
      "side": 1,
      "message": "Yea. You right. But parentStack.enterSchemaTree will throw IllegalArgumentException if didn\u0027t find the child - so if we got to this line means child was found and it is already in the stack.",
      "parentUuid": "09861925_86e6fab1",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53e0fee8_573f5b2b",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 193,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T07:25:22Z",
      "side": 1,
      "message": "It means that checking if stack is not empty is useless?",
      "parentUuid": "e70940d7_3faf0811",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73dd1b99_4d661660",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 193,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T08:32:38Z",
      "side": 1,
      "message": "After enterSchemaTree - yes. (See https://www.javadoc.io/static/org.opendaylight.yangtools/yangtools-docs/11.0.0/org/opendaylight/yangtools/yang/model/util/SchemaInferenceStack.html#enterSchemaTree(org.opendaylight.yangtools.yang.model.api.stmt.SchemaNodeIdentifier))\nCatching IllegalArgumentException is checking if something was found.",
      "parentUuid": "53e0fee8_573f5b2b",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "373a124c_3e53240b",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 196,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-02T12:23:39Z",
      "side": 1,
      "message": "error?",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25b61399_88e856ab",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 196,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-02T14:12:56Z",
      "side": 1,
      "message": "Not in this case. Ideally it should be and it was until I thought about \"What if parent of this exact node is wildcard?\". Then I can\u0027t throw error here if child was not found. I have to go through every parent. Of course having wildcard parent and them all of a sudden have namespace for the children is unlikely scenario that may happen only if someone deliberately create such filter - I agree. But if someone will do such thing then this method will still return usable SubtreeFilter.\n\nCheck for if any child(ren) was found is universal for exact and wildcard - line 201 with error thrown on line 212.",
      "parentUuid": "373a124c_3e53240b",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb4e2b2a_eacea46c",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 196,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T07:25:22Z",
      "side": 1,
      "message": "Its an error or warning, at least.\n\nPlease follow: https://docs.opendaylight.org/en/latest/developer-guides/logging-subsystem.html",
      "parentUuid": "25b61399_88e856ab",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6471e614_cd1fc7a3",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 196,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T08:32:38Z",
      "side": 1,
      "message": "Mm.. I\u0027m not sure if I can agree just yet with that. As I said above, if parent is wildcard(and there is two or more parent stacks) and we are looking for Exact match then node we are looking for is one and only under one of the parent stacks, right? It may not be under first parent - then this log is normal situation when we checked one of the possible parents and node was not there.\nIs this an error in this case? I think no - if node was not found under one parent then it is under other.\nIs this irregular situation? Not likely because such XML(I mean when there is wildcard and under wildcard there is exact node) has valid structure. May be not something logical from user to create such filter but why not. As long as there is one node that match to exact namespace then it is ok filter IMO.\nThis log is here just to note where we looked and didn\u0027t find it - that is normal.\nError is thrown below when we looked for node in how many parents we have and still didn\u0027t find it.",
      "parentUuid": "eb4e2b2a_eacea46c",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32f0813d_200c86a6",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 317,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-05-12T07:26:28Z",
      "side": 1,
      "message": "attribute must have some namespace - why? it can be wildcarded as well?",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e37ee7f2_b0e88b5e",
        "filename": "protocol/databind/src/main/java/org/opendaylight/netconf/databind/subtree/SubtreeFilterReader.java",
        "patchSetId": 62
      },
      "lineNbr": 317,
      "author": {
        "id": 9063
      },
      "writtenOn": "2025-05-12T08:32:38Z",
      "side": 1,
      "message": "Current implementation of attribute nodes expect only Exact namespace selection. Because of that this check. When I asked why only Exact namespace I was told to leave Attributes until yang definitions is done - after that this method is object to refactor. Related FIXME is few lines below - line 331",
      "parentUuid": "32f0813d_200c86a6",
      "revId": "1df5f39ea36fb3ecf71f544893a487e191ab7c84",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ]
}