{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "55880285_bd39ff69",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-02T07:43:27Z",
      "side": 1,
      "message": "IMO there seems to be no deadlock in RemoteDeviceCommunicator but in KeepaliveTask. Please investigate. A hint: there are probably more instances of KeepAlive task which may call different synchronized methods at the same time (disable and send keep alive).\n\nIIRC we wanted to rework this logic some time ago in https://lf-opendaylight.atlassian.net/browse/NETCONF-1335.",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1492827_96dab302",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8449
      },
      "writtenOn": "2025-04-02T09:01:26Z",
      "side": 1,
      "message": "Based on provided test and description, are there any doubts or uncertainties about the deadlock caused in RemoteDeviceCommunicator?\n\nThere are no multiple instances of KeepaliveTask per device. The KeepaliveTask is created only once when a new device is connected.\nhttps://github.com/opendaylight/netconf/blob/v8.0.7/plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/spi/KeepaliveSalFacade.java#L134\n\nYou made the same conclusion here:\nhttps://git.opendaylight.org/gerrit/c/netconf/+/112268/comments/3e0513e1_1bdf65cf\n\nThere could be multiple planned instances of HashedWheelTimeout with scheduled execution for the same instance of KeepaliveTask at the same time. But this should be resolved with:\nhttps://lf-opendaylight.atlassian.net/browse/NETCONF-1318",
      "parentUuid": "55880285_bd39ff69",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b71b54c_bbbc995f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-02T09:18:05Z",
      "side": 1,
      "message": "Yes, there are doubts: for me it seems both threads are blocked in KeepaliveTask...",
      "parentUuid": "c1492827_96dab302",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c9a0198_fec0c949",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8449
      },
      "writtenOn": "2025-04-02T09:58:09Z",
      "side": 1,
      "message": "Yes they are blocked in `KeepaliveTask` but also in `NetconfDeviceCommunicator`.\n\nBased on task description, two threads are blocked:\n1) `NetconfDeviceCommunicator#teardown` holds sessionLock and waits for `KeepaliveTask#sendKeepalive` to finish.\n\n2) `KeepaliveTask#sendKeepalive` holds the KeepaliveTask lock and waits for\nNetconfDeviceCommunicator#teardown to release sessionLock in `NetconfDeviceCommunicator#sendRequest` method.\n\n`The KeepaliveTask behavior is correct` because (Correct me if I am wrong):\nKeepaliveTask#disableKeepalive should be executed when KeepaliveTask#sendKeepalive is finished, and vice versa. There is no option for any part of either method to be executed while the other method is not finished yet.\n\nOn the other hand, `in NetconfDeviceCommunicator, the blocked methods are`:\nNetconfDeviceCommunicator#sendRequest and NetconfDeviceCommunicator#tearDown\n\nThese could be divided, and some parts of the code may be executed while the other method is running. This leads to the proposed solution to divide NetconfClientSession and RemoteDevice execution, which could be done in parallel. This will unblock executionÂ of NetconfDeviceCommunicator#sendRequest method.",
      "parentUuid": "6b71b54c_bbbc995f",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72489374_45a1f118",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-02T12:21:05Z",
      "side": 1,
      "message": "ACK, this solution means that: we just not do keepalive disable to allow disconnect to proceed, then the last keepalive fails with:\n```\nLOG.warn(\"{}: Session is disconnected, failing RPC request {}\", id, message);\n```\nAs last step we disable any further keepalives.",
      "parentUuid": "7c9a0198_fec0c949",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e06b6273_32b7e19c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-07T10:28:00Z",
      "side": 1,
      "message": "This approach introduces additional lock with not well defined purpose and introduces additional local variables which are redundant.\n\nInstead I propose to improve locking in KeepAlive task to do not hold lock when invoking external method - which seems to be more simple solution to the problem.\n\nPlease see and complete: https://git.opendaylight.org/gerrit/c/netconf/+/116168",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd71cfac_eb6fe4fa",
        "filename": "plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicator.java",
        "patchSetId": 5
      },
      "lineNbr": 141,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-02T12:21:05Z",
      "side": 1,
      "message": "change locking here is IMO not needed and somehow \"not correct\" as we using remoteSessionCapabilities set by `session`",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dddfac1f_e842baf1",
        "filename": "plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicator.java",
        "patchSetId": 5
      },
      "lineNbr": 141,
      "author": {
        "id": 8449
      },
      "writtenOn": "2025-04-02T13:50:39Z",
      "side": 1,
      "message": "We are using netconfSessionPreferences, which creates a hard copy of session capabilities:\nhttps://github.com/opendaylight/netconf/blob/v8.0.7/plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/api/NetconfSessionPreferences.java#L109\n\nI would prefer to keep RemoteDevice methods separated from sessionLock.",
      "parentUuid": "fd71cfac_eb6fe4fa",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a89190d_b13183f7",
        "filename": "plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicator.java",
        "patchSetId": 5
      },
      "lineNbr": 187,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-02T12:21:05Z",
      "side": 1,
      "message": "if (currentSession \u003d null) an we can eliminate isCurrentSessionClosed?",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e4a7d7ba_07a4b96c",
        "filename": "plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicator.java",
        "patchSetId": 5
      },
      "lineNbr": 187,
      "author": {
        "id": 8449
      },
      "writtenOn": "2025-04-02T13:50:39Z",
      "side": 1,
      "message": "No. If we call remoteDevice.onRemoteSessionDown() on a session that has already been removed (When tearDown method starts, the currentSession \u003d\u003d null). We receive a test failure here:\nhttps://github.com/opendaylight/netconf/blob/v8.0.7/plugins/netconf-client-mdsal/src/test/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicatorTest.java#L190\n\nIndicating that this is an invalid state.",
      "parentUuid": "3a89190d_b13183f7",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ebccb3e9_1048a545",
        "filename": "plugins/netconf-client-mdsal/src/main/java/org/opendaylight/netconf/client/mdsal/NetconfDeviceCommunicator.java",
        "patchSetId": 5
      },
      "lineNbr": 187,
      "author": {
        "id": 8144
      },
      "writtenOn": "2025-04-07T10:26:17Z",
      "side": 1,
      "message": "IMHO this variable is useless and test case full of mocking needs to be investigated to understand why this happens.",
      "parentUuid": "e4a7d7ba_07a4b96c",
      "revId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "A maximum vote is required for the \u0027Code-Review\u0027 label. \t\t\tA minumum vote is blocking."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MIN"],"failingAtoms":["label:Code-Review=MAX"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "A maximum \u0027Verified\u0027 vote from \u0027ODL Required.GHA\u0027 and one other CI or committer is required for the \u0027Verified\u0027 label. A minimum vote is blocking."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Verified\u003dMAX,count\u003e\u003d2 AND -label:Verified\u003dMIN"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Verified=MAX,count>=2 AND -label:Verified=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Verified=MAX,count>=2"],"failingAtoms":["label:Verified=MIN"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "7922b96277f46978064bc8fe6cf32f37ad3ff29f",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}